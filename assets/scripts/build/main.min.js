/*! jQuery Migrate v1.1.0 | (c) 2005, 2013 jQuery Foundation, Inc. and other contributors | jquery.org/license */
jQuery.migrateMute === void 0 && (jQuery.migrateMute = !0), function(e, t, n) {
    "use strict";
    function r(n) {
        o[n] || (o[n] = !0, e.migrateWarnings.push(n), t.console && console.warn && !e.migrateMute && (console.warn("JQMIGRATE: " + n), 
        e.migrateTrace && console.trace && console.trace()));
    }
    function a(t, a, o, i) {
        if (Object.defineProperty) try {
            return Object.defineProperty(t, a, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                    return r(i), o;
                },
                set: function(e) {
                    r(i), o = e;
                }
            }), n;
        } catch (s) {}
        e._definePropertyBroken = !0, t[a] = o;
    }
    var o = {};
    e.migrateWarnings = [], !e.migrateMute && t.console && console.log && console.log("JQMIGRATE: Logging is active"), 
    e.migrateTrace === n && (e.migrateTrace = !0), e.migrateReset = function() {
        o = {}, e.migrateWarnings.length = 0;
    }, "BackCompat" === document.compatMode && r("jQuery is not compatible with Quirks Mode");
    var i = {}, s = e.attr, u = e.attrHooks.value && e.attrHooks.value.get || function() {
        return null;
    }, c = e.attrHooks.value && e.attrHooks.value.set || function() {
        return n;
    }, l = /^(?:input|button)$/i, d = /^[238]$/, p = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, f = /^(?:checked|selected)$/i;
    a(e, "attrFn", i, "jQuery.attrFn is deprecated"), e.attr = function(t, a, o, i) {
        var u = a.toLowerCase(), c = t && t.nodeType;
        return i && 4 > s.length && (r("jQuery.fn.attr( props, pass ) is deprecated"), t && !d.test(c) && e.isFunction(e.fn[a])) ? e(t)[a](o) : ("type" === a && o !== n && l.test(t.nodeName) && t.parentNode && r("Can't change the 'type' of an input or button in IE 6/7/8"), 
        !e.attrHooks[u] && p.test(u) && (e.attrHooks[u] = {
            get: function(t, r) {
                var a, o = e.prop(t, r);
                return o === !0 || "boolean" != typeof o && (a = t.getAttributeNode(r)) && a.nodeValue !== !1 ? r.toLowerCase() : n;
            },
            set: function(t, n, r) {
                var a;
                return n === !1 ? e.removeAttr(t, r) : (a = e.propFix[r] || r, a in t && (t[a] = !0), 
                t.setAttribute(r, r.toLowerCase())), r;
            }
        }, f.test(u) && r("jQuery.fn.attr('" + u + "') may use property instead of attribute")), 
        s.call(e, t, a, o));
    }, e.attrHooks.value = {
        get: function(e, t) {
            var n = (e.nodeName || "").toLowerCase();
            return "button" === n ? u.apply(this, arguments) : ("input" !== n && "option" !== n && r("jQuery.fn.attr('value') no longer gets properties"), 
            t in e ? e.value : null);
        },
        set: function(e, t) {
            var a = (e.nodeName || "").toLowerCase();
            return "button" === a ? c.apply(this, arguments) : ("input" !== a && "option" !== a && r("jQuery.fn.attr('value', val) no longer sets properties"), 
            e.value = t, n);
        }
    };
    var g, h, v = e.fn.init, m = e.parseJSON, y = /^(?:[^<]*(<[\w\W]+>)[^>]*|#([\w\-]*))$/;
    e.fn.init = function(t, n, a) {
        var o;
        return t && "string" == typeof t && !e.isPlainObject(n) && (o = y.exec(t)) && o[1] && ("<" !== t.charAt(0) && r("$(html) HTML strings must start with '<' character"), 
        n && n.context && (n = n.context), e.parseHTML) ? v.call(this, e.parseHTML(e.trim(t), n, !0), n, a) : v.apply(this, arguments);
    }, e.fn.init.prototype = e.fn, e.parseJSON = function(e) {
        return e || null === e ? m.apply(this, arguments) : (r("jQuery.parseJSON requires a valid JSON string"), 
        null);
    }, e.uaMatch = function(e) {
        e = e.toLowerCase();
        var t = /(chrome)[ \/]([\w.]+)/.exec(e) || /(webkit)[ \/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || 0 > e.indexOf("compatible") && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
        return {
            browser: t[1] || "",
            version: t[2] || "0"
        };
    }, g = e.uaMatch(navigator.userAgent), h = {}, g.browser && (h[g.browser] = !0, 
    h.version = g.version), h.chrome ? h.webkit = !0 : h.webkit && (h.safari = !0), 
    e.browser = h, a(e, "browser", h, "jQuery.browser is deprecated"), e.sub = function() {
        function t(e, n) {
            return new t.fn.init(e, n);
        }
        e.extend(!0, t, this), t.superclass = this, t.fn = t.prototype = this(), t.fn.constructor = t, 
        t.sub = this.sub, t.fn.init = function(r, a) {
            return a && a instanceof e && !(a instanceof t) && (a = t(a)), e.fn.init.call(this, r, a, n);
        }, t.fn.init.prototype = t.fn;
        var n = t(document);
        return r("jQuery.sub() is deprecated"), t;
    };
    var b = e.fn.data;
    e.fn.data = function(t) {
        var a, o, i = this[0];
        return !i || "events" !== t || 1 !== arguments.length || (a = e.data(i, t), o = e._data(i, t), 
        a !== n && a !== o || o === n) ? b.apply(this, arguments) : (r("Use of jQuery.fn.data('events') is deprecated"), 
        o);
    };
    var j = /\/(java|ecma)script/i, w = e.fn.andSelf || e.fn.addBack;
    e.fn.andSelf = function() {
        return r("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()"), w.apply(this, arguments);
    }, e.clean || (e.clean = function(t, a, o, i) {
        a = a || document, a = !a.nodeType && a[0] || a, a = a.ownerDocument || a, r("jQuery.clean() is deprecated");
        var s, u, c, l, d = [];
        if (e.merge(d, e.buildFragment(t, a).childNodes), o) for (c = function(e) {
            return !e.type || j.test(e.type) ? i ? i.push(e.parentNode ? e.parentNode.removeChild(e) : e) : o.appendChild(e) : n;
        }, s = 0; null != (u = d[s]); s++) e.nodeName(u, "script") && c(u) || (o.appendChild(u), 
        u.getElementsByTagName !== n && (l = e.grep(e.merge([], u.getElementsByTagName("script")), c), 
        d.splice.apply(d, [ s + 1, 0 ].concat(l)), s += l.length));
        return d;
    });
    var Q = e.event.add, x = e.event.remove, k = e.event.trigger, N = e.fn.toggle, C = e.fn.live, T = e.fn.die, M = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess", S = RegExp("\\b(?:" + M + ")\\b"), H = /(?:^|\s)hover(\.\S+|)\b/, A = function(t) {
        return "string" != typeof t || e.event.special.hover ? t : (H.test(t) && r("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'"), 
        t && t.replace(H, "mouseenter$1 mouseleave$1"));
    };
    e.event.props && "attrChange" !== e.event.props[0] && e.event.props.unshift("attrChange", "attrName", "relatedNode", "srcElement"), 
    e.event.dispatch && a(e.event, "handle", e.event.dispatch, "jQuery.event.handle is undocumented and deprecated"), 
    e.event.add = function(e, t, n, a, o) {
        e !== document && S.test(t) && r("AJAX events should be attached to document: " + t), 
        Q.call(this, e, A(t || ""), n, a, o);
    }, e.event.remove = function(e, t, n, r, a) {
        x.call(this, e, A(t) || "", n, r, a);
    }, e.fn.error = function() {
        var e = Array.prototype.slice.call(arguments, 0);
        return r("jQuery.fn.error() is deprecated"), e.splice(0, 0, "error"), arguments.length ? this.bind.apply(this, e) : (this.triggerHandler.apply(this, e), 
        this);
    }, e.fn.toggle = function(t, n) {
        if (!e.isFunction(t) || !e.isFunction(n)) return N.apply(this, arguments);
        r("jQuery.fn.toggle(handler, handler...) is deprecated");
        var a = arguments, o = t.guid || e.guid++, i = 0, s = function(n) {
            var r = (e._data(this, "lastToggle" + t.guid) || 0) % i;
            return e._data(this, "lastToggle" + t.guid, r + 1), n.preventDefault(), a[r].apply(this, arguments) || !1;
        };
        for (s.guid = o; a.length > i; ) a[i++].guid = o;
        return this.click(s);
    }, e.fn.live = function(t, n, a) {
        return r("jQuery.fn.live() is deprecated"), C ? C.apply(this, arguments) : (e(this.context).on(t, this.selector, n, a), 
        this);
    }, e.fn.die = function(t, n) {
        return r("jQuery.fn.die() is deprecated"), T ? T.apply(this, arguments) : (e(this.context).off(t, this.selector || "**", n), 
        this);
    }, e.event.trigger = function(e, t, n, a) {
        return !n & !S.test(e) && r("Global events are undocumented and deprecated"), k.call(this, e, t, n || document, a);
    }, e.each(M.split("|"), function(t, n) {
        e.event.special[n] = {
            setup: function() {
                var t = this;
                return t !== document && (e.event.add(document, n + "." + e.guid, function() {
                    e.event.trigger(n, null, t, !0);
                }), e._data(this, n, e.guid++)), !1;
            },
            teardown: function() {
                return this !== document && e.event.remove(document, n + "." + e._data(this, n)), 
                !1;
            }
        };
    });
}(jQuery, window);

/**
 * jQuery.fastClick.js
 *
 * Work around the 300ms delay for the click event in some mobile browsers.
 *
 * Code based on <http://code.google.com/mobile/articles/fast_buttons.html>
 *
 * @usage
 * $('button').fastClick(function() {alert('clicked!');});
 *
 * @license Under Creative Commons Attribution 3.0 License
 * @author Dave Hulbert (dave1010)
 * @version 0.2 2011-09-20
 */
/*global document, window, jQuery, Math */
(function($) {
    $.fn.fastClick = function(handler) {
        return $(this).each(function() {
            $.FastButton($(this)[0], handler);
        });
    };
    $.FastButton = function(element, handler) {
        var startX, startY;
        var reset = function() {
            $(element).unbind("touchend");
            $("body").unbind("touchmove.fastClick");
        };
        var onClick = function(event) {
            event.stopPropagation();
            reset();
            handler.call(this, event);
            if (event.type === "touchend") {
                $.clickbuster.preventGhostClick(startX, startY);
            }
        };
        var onTouchMove = function(event) {
            if (Math.abs(event.originalEvent.touches[0].clientX - startX) > 10 || Math.abs(event.originalEvent.touches[0].clientY - startY) > 10) {
                reset();
            }
        };
        var onTouchStart = function(event) {
            event.stopPropagation();
            $(element).bind("touchend", onClick);
            $("body").bind("touchmove.fastClick", onTouchMove);
            startX = event.originalEvent.touches[0].clientX;
            startY = event.originalEvent.touches[0].clientY;
        };
        $(element).bind({
            touchstart: onTouchStart,
            click: onClick
        });
    };
    $.clickbuster = {
        coordinates: [],
        preventGhostClick: function(x, y) {
            $.clickbuster.coordinates.push(x, y);
            window.setTimeout($.clickbuster.pop, 2500);
        },
        pop: function() {
            $.clickbuster.coordinates.splice(0, 2);
        },
        onClick: function(event) {
            var x, y, i;
            for (i = 0; i < $.clickbuster.coordinates.length; i += 2) {
                x = $.clickbuster.coordinates[i];
                y = $.clickbuster.coordinates[i + 1];
                if (Math.abs(event.clientX - x) < 25 && Math.abs(event.clientY - y) < 25) {
                    event.stopPropagation();
                    event.preventDefault();
                }
            }
        }
    };
    $(function() {
        if (document.addEventListener) {
            document.addEventListener("click", $.clickbuster.onClick, true);
        } else if (document.attachEvent) {
            // for IE 7/8
            document.attachEvent("onclick", $.clickbuster.onClick);
        }
    });
})(jQuery);

/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */
// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.
// 
// Topic: Note for non-jQuery users
// 
// jQuery isn't actually required for this plugin, because nothing internal
// uses any jQuery methods or properties. jQuery is just used as a namespace
// under which these methods can exist.
// 
// Since jQuery isn't actually required for this plugin, if jQuery doesn't exist
// when this plugin is loaded, the method described below will be created in
// the `Cowboy` namespace. Usage will be exactly the same, but instead of
// $.method() or jQuery.method(), you'll need to use Cowboy.method().
(function(window, undefined) {
    "$:nomunge";
    // Used by YUI compressor.
    // Since jQuery really isn't required for this plugin, use `jQuery` as the
    // namespace only if it already exists, otherwise use the `Cowboy` namespace,
    // creating it if necessary.
    var $ = window.jQuery || window.Cowboy || (window.Cowboy = {}), // Internal method reference.
    jq_throttle;
    // Method: jQuery.throttle
    // 
    // Throttle execution of a function. Especially useful for rate limiting
    // execution of handlers on events like resize and scroll. If you want to
    // rate-limit execution of a function to a single time, see the
    // <jQuery.debounce> method.
    // 
    // In this visualization, | is a throttled-function call and X is the actual
    // callback execution:
    // 
    // > Throttled with `no_trailing` specified as false or unspecified:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X    X    X    X    X    X        X    X    X    X    X    X
    // > 
    // > Throttled with `no_trailing` specified as true:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X    X    X    X    X             X    X    X    X    X
    // 
    // Usage:
    // 
    // > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
    // > 
    // > jQuery('selector').bind( 'someevent', throttled );
    // > jQuery('selector').unbind( 'someevent', throttled );
    // 
    // This also works in jQuery 1.4+:
    // 
    // > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
    // > jQuery('selector').unbind( 'someevent', callback );
    // 
    // Arguments:
    // 
    //  delay - (Number) A zero-or-greater delay in milliseconds. For event
    //    callbacks, values around 100 or 250 (or even higher) are most useful.
    //  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
    //    true, callback will only execute every `delay` milliseconds while the
    //    throttled-function is being called. If no_trailing is false or
    //    unspecified, callback will be executed one final time after the last
    //    throttled-function call. (After the throttled-function has not been
    //    called for `delay` milliseconds, the internal counter is reset)
    //  callback - (Function) A function to be executed after delay milliseconds.
    //    The `this` context and all arguments are passed through, as-is, to
    //    `callback` when the throttled-function is executed.
    // 
    // Returns:
    // 
    //  (Function) A new, throttled, function.
    $.throttle = jq_throttle = function(delay, no_trailing, callback, debounce_mode) {
        // After wrapper has stopped being called, this timeout ensures that
        // `callback` is executed at the proper times in `throttle` and `end`
        // debounce modes.
        var timeout_id, // Keep track of the last time `callback` was executed.
        last_exec = 0;
        // `no_trailing` defaults to falsy.
        if (typeof no_trailing !== "boolean") {
            debounce_mode = callback;
            callback = no_trailing;
            no_trailing = undefined;
        }
        // The `wrapper` function encapsulates all of the throttling / debouncing
        // functionality and when executed will limit the rate at which `callback`
        // is executed.
        function wrapper() {
            var that = this, elapsed = +new Date() - last_exec, args = arguments;
            // Execute `callback` and update the `last_exec` timestamp.
            function exec() {
                last_exec = +new Date();
                callback.apply(that, args);
            }
            // If `debounce_mode` is true (at_begin) this is used to clear the flag
            // to allow future `callback` executions.
            function clear() {
                timeout_id = undefined;
            }
            if (debounce_mode && !timeout_id) {
                // Since `wrapper` is being called for the first time and
                // `debounce_mode` is true (at_begin), execute `callback`.
                exec();
            }
            // Clear any existing timeout.
            timeout_id && clearTimeout(timeout_id);
            if (debounce_mode === undefined && elapsed > delay) {
                // In throttle mode, if `delay` time has been exceeded, execute
                // `callback`.
                exec();
            } else if (no_trailing !== true) {
                // In trailing throttle mode, since `delay` time has not been
                // exceeded, schedule `callback` to execute `delay` ms after most
                // recent execution.
                // 
                // If `debounce_mode` is true (at_begin), schedule `clear` to execute
                // after `delay` ms.
                // 
                // If `debounce_mode` is false (at end), schedule `callback` to
                // execute after `delay` ms.
                timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
            }
        }
        // Set the guid of `wrapper` function to the same of original callback, so
        // it can be removed in jQuery 1.4+ .unbind or .die by using the original
        // callback as a reference.
        if ($.guid) {
            wrapper.guid = callback.guid = callback.guid || $.guid++;
        }
        // Return the wrapper function.
        return wrapper;
    };
    // Method: jQuery.debounce
    // 
    // Debounce execution of a function. Debouncing, unlike throttling,
    // guarantees that a function is only executed a single time, either at the
    // very beginning of a series of calls, or at the very end. If you want to
    // simply rate-limit execution of a function, see the <jQuery.throttle>
    // method.
    // 
    // In this visualization, | is a debounced-function call and X is the actual
    // callback execution:
    // 
    // > Debounced with `at_begin` specified as false or unspecified:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // >                          X                                 X
    // > 
    // > Debounced with `at_begin` specified as true:
    // > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
    // > X                                 X
    // 
    // Usage:
    // 
    // > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
    // > 
    // > jQuery('selector').bind( 'someevent', debounced );
    // > jQuery('selector').unbind( 'someevent', debounced );
    // 
    // This also works in jQuery 1.4+:
    // 
    // > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
    // > jQuery('selector').unbind( 'someevent', callback );
    // 
    // Arguments:
    // 
    //  delay - (Number) A zero-or-greater delay in milliseconds. For event
    //    callbacks, values around 100 or 250 (or even higher) are most useful.
    //  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
    //    unspecified, callback will only be executed `delay` milliseconds after
    //    the last debounced-function call. If at_begin is true, callback will be
    //    executed only at the first debounced-function call. (After the
    //    throttled-function has not been called for `delay` milliseconds, the
    //    internal counter is reset)
    //  callback - (Function) A function to be executed after delay milliseconds.
    //    The `this` context and all arguments are passed through, as-is, to
    //    `callback` when the debounced-function is executed.
    // 
    // Returns:
    // 
    //  (Function) A new, debounced, function.
    $.debounce = function(delay, at_begin, callback) {
        return callback === undefined ? jq_throttle(delay, at_begin, false) : jq_throttle(delay, callback, at_begin !== false);
    };
})(this);

// Chosen, a Select Box Enhancer for jQuery and Prototype
// by Patrick Filler for Harvest, http://getharvest.com
//
// Version 0.9.15
// Full source at https://github.com/harvesthq/chosen
// Copyright (c) 2011 Harvest http://getharvest.com
// MIT License, https://github.com/harvesthq/chosen/blob/master/LICENSE.md
// This file is generated by `cake build`, do not edit it by hand.
(function() {
    var SelectParser;
    SelectParser = function() {
        function SelectParser() {
            this.options_index = 0;
            this.parsed = [];
        }
        SelectParser.prototype.add_node = function(child) {
            if (child.nodeName.toUpperCase() === "OPTGROUP") {
                return this.add_group(child);
            } else {
                return this.add_option(child);
            }
        };
        SelectParser.prototype.add_group = function(group) {
            var group_position, option, _i, _len, _ref, _results;
            group_position = this.parsed.length;
            this.parsed.push({
                array_index: group_position,
                group: true,
                label: group.label,
                children: 0,
                disabled: group.disabled
            });
            _ref = group.childNodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                _results.push(this.add_option(option, group_position, group.disabled));
            }
            return _results;
        };
        SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
            if (option.nodeName.toUpperCase() === "OPTION") {
                if (option.text !== "") {
                    if (group_position != null) {
                        this.parsed[group_position].children += 1;
                    }
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        value: option.value,
                        text: option.text,
                        html: option.innerHTML,
                        selected: option.selected,
                        disabled: group_disabled === true ? group_disabled : option.disabled,
                        group_array_index: group_position,
                        classes: option.className,
                        style: option.style.cssText
                    });
                } else {
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        empty: true
                    });
                }
                return this.options_index += 1;
            }
        };
        return SelectParser;
    }();
    SelectParser.select_to_array = function(select) {
        var child, parser, _i, _len, _ref;
        parser = new SelectParser();
        _ref = select.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            parser.add_node(child);
        }
        return parser.parsed;
    };
    this.SelectParser = SelectParser;
}).call(this);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/
(function() {
    var AbstractChosen, root;
    root = this;
    AbstractChosen = function() {
        function AbstractChosen(form_field, options) {
            this.form_field = form_field;
            this.options = options != null ? options : {};
            if (!AbstractChosen.browser_is_supported()) {
                return;
            }
            this.is_multiple = this.form_field.multiple;
            this.set_default_text();
            this.set_default_values();
            this.setup();
            this.set_up_html();
            this.register_observers();
            this.finish_setup();
        }
        AbstractChosen.prototype.set_default_values = function() {
            var _this = this;
            this.click_test_action = function(evt) {
                return _this.test_active_click(evt);
            };
            this.activate_action = function(evt) {
                return _this.activate_field(evt);
            };
            this.active_field = false;
            this.mouse_on_container = false;
            this.results_showing = false;
            this.result_highlighted = null;
            this.result_single_selected = null;
            this.allow_single_deselect = this.options.allow_single_deselect != null && this.form_field.options[0] != null && this.form_field.options[0].text === "" ? this.options.allow_single_deselect : false;
            this.disable_search_threshold = this.options.disable_search_threshold || 0;
            this.disable_search = this.options.disable_search || false;
            this.enable_split_word_search = this.options.enable_split_word_search != null ? this.options.enable_split_word_search : true;
            this.search_contains = this.options.search_contains || false;
            this.single_backstroke_delete = this.options.single_backstroke_delete || false;
            this.max_selected_options = this.options.max_selected_options || Infinity;
            return this.inherit_select_classes = this.options.inherit_select_classes || false;
        };
        AbstractChosen.prototype.set_default_text = function() {
            if (this.form_field.getAttribute("data-placeholder")) {
                this.default_text = this.form_field.getAttribute("data-placeholder");
            } else if (this.is_multiple) {
                this.default_text = this.options.placeholder_text_multiple || this.options.placeholder_text || AbstractChosen.default_multiple_text;
            } else {
                this.default_text = this.options.placeholder_text_single || this.options.placeholder_text || AbstractChosen.default_single_text;
            }
            return this.results_none_found = this.form_field.getAttribute("data-no_results_text") || this.options.no_results_text || AbstractChosen.default_no_result_text;
        };
        AbstractChosen.prototype.mouse_enter = function() {
            return this.mouse_on_container = true;
        };
        AbstractChosen.prototype.mouse_leave = function() {
            return this.mouse_on_container = false;
        };
        AbstractChosen.prototype.input_focus = function(evt) {
            var _this = this;
            if (this.is_multiple) {
                if (!this.active_field) {
                    return setTimeout(function() {
                        return _this.container_mousedown();
                    }, 50);
                }
            } else {
                if (!this.active_field) {
                    return this.activate_field();
                }
            }
        };
        AbstractChosen.prototype.input_blur = function(evt) {
            var _this = this;
            if (!this.mouse_on_container) {
                this.active_field = false;
                return setTimeout(function() {
                    return _this.blur_test();
                }, 100);
            }
        };
        AbstractChosen.prototype.result_add_option = function(option) {
            var classes, style;
            if (!option.disabled) {
                option.dom_id = this.container_id + "_o_" + option.array_index;
                classes = option.selected && this.is_multiple ? [] : [ "active-result" ];
                if (option.selected) {
                    classes.push("result-selected");
                }
                if (option.group_array_index != null) {
                    classes.push("group-option");
                }
                if (option.classes !== "") {
                    classes.push(option.classes);
                }
                style = option.style.cssText !== "" ? ' style="' + option.style + '"' : "";
                return '<li id="' + option.dom_id + '" class="' + classes.join(" ") + '"' + style + ">" + option.html + "</li>";
            } else {
                return "";
            }
        };
        AbstractChosen.prototype.results_update_field = function() {
            this.set_default_text();
            if (!this.is_multiple) {
                this.results_reset_cleanup();
            }
            this.result_clear_highlight();
            this.result_single_selected = null;
            return this.results_build();
        };
        AbstractChosen.prototype.results_toggle = function() {
            if (this.results_showing) {
                return this.results_hide();
            } else {
                return this.results_show();
            }
        };
        AbstractChosen.prototype.results_search = function(evt) {
            if (this.results_showing) {
                return this.winnow_results();
            } else {
                return this.results_show();
            }
        };
        AbstractChosen.prototype.choices_count = function() {
            var option, _i, _len, _ref;
            if (this.selected_option_count != null) {
                return this.selected_option_count;
            }
            this.selected_option_count = 0;
            _ref = this.form_field.options;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                if (option.selected) {
                    this.selected_option_count += 1;
                }
            }
            return this.selected_option_count;
        };
        AbstractChosen.prototype.choices_click = function(evt) {
            evt.preventDefault();
            if (!this.results_showing) {
                return this.results_show();
            }
        };
        AbstractChosen.prototype.keyup_checker = function(evt) {
            var stroke, _ref;
            stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
            this.search_field_scale();
            switch (stroke) {
              case 8:
                if (this.is_multiple && this.backstroke_length < 1 && this.choices_count() > 0) {
                    return this.keydown_backstroke();
                } else if (!this.pending_backstroke) {
                    this.result_clear_highlight();
                    return this.results_search();
                }
                break;

              case 13:
                evt.preventDefault();
                if (this.results_showing) {
                    return this.result_select(evt);
                }
                break;

              case 27:
                if (this.results_showing) {
                    this.results_hide();
                }
                return true;

              case 9:
              case 38:
              case 40:
              case 16:
              case 91:
              case 17:
                break;

              default:
                return this.results_search();
            }
        };
        AbstractChosen.prototype.generate_field_id = function() {
            var new_id;
            new_id = this.generate_random_id();
            this.form_field.id = new_id;
            return new_id;
        };
        AbstractChosen.prototype.generate_random_char = function() {
            var chars, newchar, rand;
            chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
            rand = Math.floor(Math.random() * chars.length);
            return newchar = chars.substring(rand, rand + 1);
        };
        AbstractChosen.prototype.container_width = function() {
            if (this.options.width != null) {
                return this.options.width;
            } else {
                return "" + this.form_field.offsetWidth + "px";
            }
        };
        AbstractChosen.browser_is_supported = function() {
            var _ref;
            if (window.navigator.appName === "Microsoft Internet Explorer") {
                return null !== (_ref = document.documentMode) && _ref >= 8;
            }
            return true;
        };
        AbstractChosen.default_multiple_text = "Select Some Options";
        AbstractChosen.default_single_text = "Select an Option";
        AbstractChosen.default_no_result_text = "No results match";
        return AbstractChosen;
    }();
    root.AbstractChosen = AbstractChosen;
}).call(this);

/*
Chosen source: generate output using 'cake build'
Copyright (c) 2011 by Harvest
*/
(function() {
    var $, Chosen, root, _ref, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
        for (var key in parent) {
            if (__hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
    };
    root = this;
    $ = jQuery;
    $.fn.extend({
        chosen: function(options) {
            if (!AbstractChosen.browser_is_supported()) {
                return this;
            }
            return this.each(function(input_field) {
                var $this;
                $this = $(this);
                if (!$this.hasClass("chzn-done")) {
                    return $this.data("chosen", new Chosen(this, options));
                }
            });
        }
    });
    Chosen = function(_super) {
        __extends(Chosen, _super);
        function Chosen() {
            _ref = Chosen.__super__.constructor.apply(this, arguments);
            return _ref;
        }
        Chosen.prototype.setup = function() {
            this.form_field_jq = $(this.form_field);
            this.current_selectedIndex = this.form_field.selectedIndex;
            return this.is_rtl = this.form_field_jq.hasClass("chzn-rtl");
        };
        Chosen.prototype.finish_setup = function() {
            return this.form_field_jq.addClass("chzn-done");
        };
        Chosen.prototype.set_up_html = function() {
            var container_classes, container_props;
            this.container_id = this.form_field.id.length ? this.form_field.id.replace(/[^\w]/g, "_") : this.generate_field_id();
            this.container_id += "_chzn";
            container_classes = [ "chzn-container" ];
            container_classes.push("chzn-container-" + (this.is_multiple ? "multi" : "single"));
            if (this.inherit_select_classes && this.form_field.className) {
                container_classes.push(this.form_field.className);
            }
            if (this.is_rtl) {
                container_classes.push("chzn-rtl");
            }
            container_props = {
                id: this.container_id,
                "class": container_classes.join(" "),
                style: "width: " + this.container_width() + ";",
                title: this.form_field.title
            };
            this.container = $("<div />", container_props);
            if (this.is_multiple) {
                this.container.html('<ul class="chzn-choices"><li class="search-field"><input type="text" value="' + this.default_text + '" class="default" autocomplete="off" style="width:25px;" /></li></ul><div class="chzn-drop"><ul class="chzn-results"></ul></div>');
            } else {
                this.container.html('<a href="javascript:void(0)" class="chzn-single chzn-default" tabindex="-1"><span>' + this.default_text + '</span><div><b></b></div></a><div class="chzn-drop"><div class="chzn-search"><input type="text" autocomplete="off" /></div><ul class="chzn-results"></ul></div>');
            }
            this.form_field_jq.hide().after(this.container);
            this.dropdown = this.container.find("div.chzn-drop").first();
            this.search_field = this.container.find("input").first();
            this.search_results = this.container.find("ul.chzn-results").first();
            this.search_field_scale();
            this.search_no_results = this.container.find("li.no-results").first();
            if (this.is_multiple) {
                this.search_choices = this.container.find("ul.chzn-choices").first();
                this.search_container = this.container.find("li.search-field").first();
            } else {
                this.search_container = this.container.find("div.chzn-search").first();
                this.selected_item = this.container.find(".chzn-single").first();
            }
            this.results_build();
            this.set_tab_index();
            this.set_label_behavior();
            return this.form_field_jq.trigger("liszt:ready", {
                chosen: this
            });
        };
        Chosen.prototype.register_observers = function() {
            var _this = this;
            this.container.mousedown(function(evt) {
                _this.container_mousedown(evt);
            });
            this.container.mouseup(function(evt) {
                _this.container_mouseup(evt);
            });
            this.container.mouseenter(function(evt) {
                _this.mouse_enter(evt);
            });
            this.container.mouseleave(function(evt) {
                _this.mouse_leave(evt);
            });
            this.search_results.mouseup(function(evt) {
                _this.search_results_mouseup(evt);
            });
            this.search_results.mouseover(function(evt) {
                _this.search_results_mouseover(evt);
            });
            this.search_results.mouseout(function(evt) {
                _this.search_results_mouseout(evt);
            });
            this.search_results.bind("mousewheel DOMMouseScroll", function(evt) {
                _this.search_results_mousewheel(evt);
            });
            this.form_field_jq.bind("liszt:updated", function(evt) {
                _this.results_update_field(evt);
            });
            this.form_field_jq.bind("liszt:activate", function(evt) {
                _this.activate_field(evt);
            });
            this.form_field_jq.bind("liszt:open", function(evt) {
                _this.container_mousedown(evt);
            });
            this.search_field.blur(function(evt) {
                _this.input_blur(evt);
            });
            this.search_field.keyup(function(evt) {
                _this.keyup_checker(evt);
            });
            this.search_field.keydown(function(evt) {
                _this.keydown_checker(evt);
            });
            this.search_field.focus(function(evt) {
                _this.input_focus(evt);
            });
            if (this.is_multiple) {
                return this.search_choices.click(function(evt) {
                    _this.choices_click(evt);
                });
            } else {
                return this.container.click(function(evt) {
                    evt.preventDefault();
                });
            }
        };
        Chosen.prototype.search_field_disabled = function() {
            this.is_disabled = this.form_field_jq[0].disabled;
            if (this.is_disabled) {
                this.container.addClass("chzn-disabled");
                this.search_field[0].disabled = true;
                if (!this.is_multiple) {
                    this.selected_item.unbind("focus", this.activate_action);
                }
                return this.close_field();
            } else {
                this.container.removeClass("chzn-disabled");
                this.search_field[0].disabled = false;
                if (!this.is_multiple) {
                    return this.selected_item.bind("focus", this.activate_action);
                }
            }
        };
        Chosen.prototype.container_mousedown = function(evt) {
            if (!this.is_disabled) {
                if (evt && evt.type === "mousedown" && !this.results_showing) {
                    evt.preventDefault();
                }
                if (!(evt != null && $(evt.target).hasClass("search-choice-close"))) {
                    if (!this.active_field) {
                        if (this.is_multiple) {
                            this.search_field.val("");
                        }
                        $(document).click(this.click_test_action);
                        this.results_show();
                    } else if (!this.is_multiple && evt && ($(evt.target)[0] === this.selected_item[0] || $(evt.target).parents("a.chzn-single").length)) {
                        evt.preventDefault();
                        this.results_toggle();
                    }
                    return this.activate_field();
                }
            }
        };
        Chosen.prototype.container_mouseup = function(evt) {
            if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
                return this.results_reset(evt);
            }
        };
        Chosen.prototype.search_results_mousewheel = function(evt) {
            var delta, _ref1, _ref2;
            delta = -((_ref1 = evt.originalEvent) != null ? _ref1.wheelDelta : void 0) || ((_ref2 = evt.originialEvent) != null ? _ref2.detail : void 0);
            if (delta != null) {
                evt.preventDefault();
                if (evt.type === "DOMMouseScroll") {
                    delta = delta * 40;
                }
                return this.search_results.scrollTop(delta + this.search_results.scrollTop());
            }
        };
        Chosen.prototype.blur_test = function(evt) {
            if (!this.active_field && this.container.hasClass("chzn-container-active")) {
                return this.close_field();
            }
        };
        Chosen.prototype.close_field = function() {
            $(document).unbind("click", this.click_test_action);
            this.active_field = false;
            this.results_hide();
            this.container.removeClass("chzn-container-active");
            this.winnow_results_clear();
            this.clear_backstroke();
            this.show_search_field_default();
            return this.search_field_scale();
        };
        Chosen.prototype.activate_field = function() {
            this.container.addClass("chzn-container-active");
            this.active_field = true;
            this.search_field.val(this.search_field.val());
            return this.search_field.focus();
        };
        Chosen.prototype.test_active_click = function(evt) {
            if ($(evt.target).parents("#" + this.container_id).length) {
                return this.active_field = true;
            } else {
                return this.close_field();
            }
        };
        Chosen.prototype.results_build = function() {
            var content, data, _i, _len, _ref1;
            this.parsing = true;
            this.selected_option_count = null;
            this.results_data = root.SelectParser.select_to_array(this.form_field);
            if (this.is_multiple && this.choices_count() > 0) {
                this.search_choices.find("li.search-choice").remove();
            } else if (!this.is_multiple) {
                this.selected_item.addClass("chzn-default").find("span").text(this.default_text);
                if (this.disable_search || this.form_field.options.length <= this.disable_search_threshold) {
                    this.container.addClass("chzn-container-single-nosearch");
                } else {
                    this.container.removeClass("chzn-container-single-nosearch");
                }
            }
            content = "";
            _ref1 = this.results_data;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                data = _ref1[_i];
                if (data.group) {
                    content += this.result_add_group(data);
                } else if (!data.empty) {
                    content += this.result_add_option(data);
                    if (data.selected && this.is_multiple) {
                        this.choice_build(data);
                    } else if (data.selected && !this.is_multiple) {
                        this.selected_item.removeClass("chzn-default").find("span").text(data.text);
                        if (this.allow_single_deselect) {
                            this.single_deselect_control_build();
                        }
                    }
                }
            }
            this.search_field_disabled();
            this.show_search_field_default();
            this.search_field_scale();
            this.search_results.html(content);
            return this.parsing = false;
        };
        Chosen.prototype.result_add_group = function(group) {
            if (!group.disabled) {
                group.dom_id = this.container_id + "_g_" + group.array_index;
                return '<li id="' + group.dom_id + '" class="group-result">' + $("<div />").text(group.label).html() + "</li>";
            } else {
                return "";
            }
        };
        Chosen.prototype.result_do_highlight = function(el) {
            var high_bottom, high_top, maxHeight, visible_bottom, visible_top;
            if (el.length) {
                this.result_clear_highlight();
                this.result_highlight = el;
                this.result_highlight.addClass("highlighted");
                maxHeight = parseInt(this.search_results.css("maxHeight"), 10);
                visible_top = this.search_results.scrollTop();
                visible_bottom = maxHeight + visible_top;
                high_top = this.result_highlight.position().top + this.search_results.scrollTop();
                high_bottom = high_top + this.result_highlight.outerHeight();
                if (high_bottom >= visible_bottom) {
                    return this.search_results.scrollTop(high_bottom - maxHeight > 0 ? high_bottom - maxHeight : 0);
                } else if (high_top < visible_top) {
                    return this.search_results.scrollTop(high_top);
                }
            }
        };
        Chosen.prototype.result_clear_highlight = function() {
            if (this.result_highlight) {
                this.result_highlight.removeClass("highlighted");
            }
            return this.result_highlight = null;
        };
        Chosen.prototype.results_show = function() {
            if (this.result_single_selected != null) {
                this.result_do_highlight(this.result_single_selected);
            } else if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
                this.form_field_jq.trigger("liszt:maxselected", {
                    chosen: this
                });
                return false;
            }
            this.container.addClass("chzn-with-drop");
            this.form_field_jq.trigger("liszt:showing_dropdown", {
                chosen: this
            });
            this.results_showing = true;
            this.search_field.focus();
            this.search_field.val(this.search_field.val());
            return this.winnow_results();
        };
        Chosen.prototype.results_hide = function() {
            this.result_clear_highlight();
            this.container.removeClass("chzn-with-drop");
            this.form_field_jq.trigger("liszt:hiding_dropdown", {
                chosen: this
            });
            return this.results_showing = false;
        };
        Chosen.prototype.set_tab_index = function(el) {
            var ti;
            if (this.form_field_jq.attr("tabindex")) {
                ti = this.form_field_jq.attr("tabindex");
                this.form_field_jq.attr("tabindex", -1);
                return this.search_field.attr("tabindex", ti);
            }
        };
        Chosen.prototype.set_label_behavior = function() {
            var _this = this;
            this.form_field_label = this.form_field_jq.parents("label");
            if (!this.form_field_label.length && this.form_field.id.length) {
                this.form_field_label = $("label[for='" + this.form_field.id + "']");
            }
            if (this.form_field_label.length > 0) {
                return this.form_field_label.click(function(evt) {
                    if (_this.is_multiple) {
                        return _this.container_mousedown(evt);
                    } else {
                        return _this.activate_field();
                    }
                });
            }
        };
        Chosen.prototype.show_search_field_default = function() {
            if (this.is_multiple && this.choices_count() < 1 && !this.active_field) {
                this.search_field.val(this.default_text);
                return this.search_field.addClass("default");
            } else {
                this.search_field.val("");
                return this.search_field.removeClass("default");
            }
        };
        Chosen.prototype.search_results_mouseup = function(evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target.length) {
                this.result_highlight = target;
                this.result_select(evt);
                return this.search_field.focus();
            }
        };
        Chosen.prototype.search_results_mouseover = function(evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target) {
                return this.result_do_highlight(target);
            }
        };
        Chosen.prototype.search_results_mouseout = function(evt) {
            if ($(evt.target).hasClass("active-result" || $(evt.target).parents(".active-result").first())) {
                return this.result_clear_highlight();
            }
        };
        Chosen.prototype.choice_build = function(item) {
            var choice, close_link, _this = this;
            choice = $("<li />", {
                "class": "search-choice"
            }).html("<span>" + item.html + "</span>");
            if (item.disabled) {
                choice.addClass("search-choice-disabled");
            } else {
                close_link = $("<a />", {
                    href: "#",
                    "class": "search-choice-close",
                    rel: item.array_index
                });
                close_link.click(function(evt) {
                    return _this.choice_destroy_link_click(evt);
                });
                choice.append(close_link);
            }
            return this.search_container.before(choice);
        };
        Chosen.prototype.choice_destroy_link_click = function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
            if (!this.is_disabled) {
                return this.choice_destroy($(evt.target));
            }
        };
        Chosen.prototype.choice_destroy = function(link) {
            if (this.result_deselect(link.attr("rel"))) {
                this.show_search_field_default();
                if (this.is_multiple && this.choices_count() > 0 && this.search_field.val().length < 1) {
                    this.results_hide();
                }
                link.parents("li").first().remove();
                return this.search_field_scale();
            }
        };
        Chosen.prototype.results_reset = function() {
            this.form_field.options[0].selected = true;
            this.selected_option_count = null;
            this.selected_item.find("span").text(this.default_text);
            if (!this.is_multiple) {
                this.selected_item.addClass("chzn-default");
            }
            this.show_search_field_default();
            this.results_reset_cleanup();
            this.form_field_jq.trigger("change");
            if (this.active_field) {
                return this.results_hide();
            }
        };
        Chosen.prototype.results_reset_cleanup = function() {
            this.current_selectedIndex = this.form_field.selectedIndex;
            return this.selected_item.find("abbr").remove();
        };
        Chosen.prototype.result_select = function(evt) {
            var high, high_id, item, position;
            if (this.result_highlight) {
                high = this.result_highlight;
                high_id = high.attr("id");
                this.result_clear_highlight();
                if (this.is_multiple && this.max_selected_options <= this.choices_count()) {
                    this.form_field_jq.trigger("liszt:maxselected", {
                        chosen: this
                    });
                    return false;
                }
                if (this.is_multiple) {
                    this.result_deactivate(high);
                } else {
                    this.search_results.find(".result-selected").removeClass("result-selected");
                    this.result_single_selected = high;
                    this.selected_item.removeClass("chzn-default");
                }
                high.addClass("result-selected");
                position = high_id.substr(high_id.lastIndexOf("_") + 1);
                item = this.results_data[position];
                item.selected = true;
                this.form_field.options[item.options_index].selected = true;
                this.selected_option_count = null;
                if (this.is_multiple) {
                    this.choice_build(item);
                } else {
                    this.selected_item.find("span").first().text(item.text);
                    if (this.allow_single_deselect) {
                        this.single_deselect_control_build();
                    }
                }
                if (!((evt.metaKey || evt.ctrlKey) && this.is_multiple)) {
                    this.results_hide();
                }
                this.search_field.val("");
                if (this.is_multiple || this.form_field.selectedIndex !== this.current_selectedIndex) {
                    this.form_field_jq.trigger("change", {
                        selected: this.form_field.options[item.options_index].value
                    });
                }
                this.current_selectedIndex = this.form_field.selectedIndex;
                return this.search_field_scale();
            }
        };
        Chosen.prototype.result_activate = function(el) {
            return el.addClass("active-result");
        };
        Chosen.prototype.result_deactivate = function(el) {
            return el.removeClass("active-result");
        };
        Chosen.prototype.result_deselect = function(pos) {
            var result, result_data;
            result_data = this.results_data[pos];
            if (!this.form_field.options[result_data.options_index].disabled) {
                result_data.selected = false;
                this.form_field.options[result_data.options_index].selected = false;
                this.selected_option_count = null;
                result = $("#" + this.container_id + "_o_" + pos);
                result.removeClass("result-selected").addClass("active-result").show();
                this.result_clear_highlight();
                this.winnow_results();
                this.form_field_jq.trigger("change", {
                    deselected: this.form_field.options[result_data.options_index].value
                });
                this.search_field_scale();
                return true;
            } else {
                return false;
            }
        };
        Chosen.prototype.single_deselect_control_build = function() {
            if (this.allow_single_deselect && this.selected_item.find("abbr").length < 1) {
                return this.selected_item.find("span").first().after('<abbr class="search-choice-close"></abbr>');
            }
        };
        Chosen.prototype.winnow_results = function() {
            var found, option, part, parts, regex, regexAnchor, result, result_id, results, searchText, startpos, text, zregex, _i, _j, _len, _len1, _ref1;
            this.no_results_clear();
            results = 0;
            searchText = this.search_field.val() === this.default_text ? "" : $("<div/>").text($.trim(this.search_field.val())).html();
            regexAnchor = this.search_contains ? "" : "^";
            regex = new RegExp(regexAnchor + searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
            zregex = new RegExp(searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), "i");
            _ref1 = this.results_data;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                option = _ref1[_i];
                if (!option.disabled && !option.empty) {
                    if (option.group) {
                        $("#" + option.dom_id).css("display", "none");
                    } else if (!(this.is_multiple && option.selected)) {
                        found = false;
                        result_id = option.dom_id;
                        result = $("#" + result_id);
                        if (regex.test(option.html)) {
                            found = true;
                            results += 1;
                        } else if (this.enable_split_word_search && (option.html.indexOf(" ") >= 0 || option.html.indexOf("[") === 0)) {
                            parts = option.html.replace(/\[|\]/g, "").split(" ");
                            if (parts.length) {
                                for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                                    part = parts[_j];
                                    if (regex.test(part)) {
                                        found = true;
                                        results += 1;
                                    }
                                }
                            }
                        }
                        if (found) {
                            if (searchText.length) {
                                startpos = option.html.search(zregex);
                                text = option.html.substr(0, startpos + searchText.length) + "</em>" + option.html.substr(startpos + searchText.length);
                                text = text.substr(0, startpos) + "<em>" + text.substr(startpos);
                            } else {
                                text = option.html;
                            }
                            result.html(text);
                            this.result_activate(result);
                            if (option.group_array_index != null) {
                                $("#" + this.results_data[option.group_array_index].dom_id).css("display", "list-item");
                            }
                        } else {
                            if (this.result_highlight && result_id === this.result_highlight.attr("id")) {
                                this.result_clear_highlight();
                            }
                            this.result_deactivate(result);
                        }
                    }
                }
            }
            if (results < 1 && searchText.length) {
                return this.no_results(searchText);
            } else {
                return this.winnow_results_set_highlight();
            }
        };
        Chosen.prototype.winnow_results_clear = function() {
            var li, lis, _i, _len, _results;
            this.search_field.val("");
            lis = this.search_results.find("li");
            _results = [];
            for (_i = 0, _len = lis.length; _i < _len; _i++) {
                li = lis[_i];
                li = $(li);
                if (li.hasClass("group-result")) {
                    _results.push(li.css("display", "auto"));
                } else if (!this.is_multiple || !li.hasClass("result-selected")) {
                    _results.push(this.result_activate(li));
                } else {
                    _results.push(void 0);
                }
            }
            return _results;
        };
        Chosen.prototype.winnow_results_set_highlight = function() {
            var do_high, selected_results;
            if (!this.result_highlight) {
                selected_results = !this.is_multiple ? this.search_results.find(".result-selected.active-result") : [];
                do_high = selected_results.length ? selected_results.first() : this.search_results.find(".active-result").first();
                if (do_high != null) {
                    return this.result_do_highlight(do_high);
                }
            }
        };
        Chosen.prototype.no_results = function(terms) {
            var no_results_html;
            no_results_html = $('<li class="no-results">' + this.results_none_found + ' "<span></span>"</li>');
            no_results_html.find("span").first().html(terms);
            return this.search_results.append(no_results_html);
        };
        Chosen.prototype.no_results_clear = function() {
            return this.search_results.find(".no-results").remove();
        };
        Chosen.prototype.keydown_arrow = function() {
            var first_active, next_sib;
            if (!this.result_highlight) {
                first_active = this.search_results.find("li.active-result").first();
                if (first_active) {
                    this.result_do_highlight($(first_active));
                }
            } else if (this.results_showing) {
                next_sib = this.result_highlight.nextAll("li.active-result").first();
                if (next_sib) {
                    this.result_do_highlight(next_sib);
                }
            }
            if (!this.results_showing) {
                return this.results_show();
            }
        };
        Chosen.prototype.keyup_arrow = function() {
            var prev_sibs;
            if (!this.results_showing && !this.is_multiple) {
                return this.results_show();
            } else if (this.result_highlight) {
                prev_sibs = this.result_highlight.prevAll("li.active-result");
                if (prev_sibs.length) {
                    return this.result_do_highlight(prev_sibs.first());
                } else {
                    if (this.choices_count() > 0) {
                        this.results_hide();
                    }
                    return this.result_clear_highlight();
                }
            }
        };
        Chosen.prototype.keydown_backstroke = function() {
            var next_available_destroy;
            if (this.pending_backstroke) {
                this.choice_destroy(this.pending_backstroke.find("a").first());
                return this.clear_backstroke();
            } else {
                next_available_destroy = this.search_container.siblings("li.search-choice").last();
                if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
                    this.pending_backstroke = next_available_destroy;
                    if (this.single_backstroke_delete) {
                        return this.keydown_backstroke();
                    } else {
                        return this.pending_backstroke.addClass("search-choice-focus");
                    }
                }
            }
        };
        Chosen.prototype.clear_backstroke = function() {
            if (this.pending_backstroke) {
                this.pending_backstroke.removeClass("search-choice-focus");
            }
            return this.pending_backstroke = null;
        };
        Chosen.prototype.keydown_checker = function(evt) {
            var stroke, _ref1;
            stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
            this.search_field_scale();
            if (stroke !== 8 && this.pending_backstroke) {
                this.clear_backstroke();
            }
            switch (stroke) {
              case 8:
                this.backstroke_length = this.search_field.val().length;
                break;

              case 9:
                if (this.results_showing && !this.is_multiple) {
                    this.result_select(evt);
                }
                this.mouse_on_container = false;
                break;

              case 13:
                evt.preventDefault();
                break;

              case 38:
                evt.preventDefault();
                this.keyup_arrow();
                break;

              case 40:
                this.keydown_arrow();
                break;
            }
        };
        Chosen.prototype.search_field_scale = function() {
            var div, h, style, style_block, styles, w, _i, _len;
            if (this.is_multiple) {
                h = 0;
                w = 0;
                style_block = "position:absolute; left: -1000px; top: -1000px; display:none;";
                styles = [ "font-size", "font-style", "font-weight", "font-family", "line-height", "text-transform", "letter-spacing" ];
                for (_i = 0, _len = styles.length; _i < _len; _i++) {
                    style = styles[_i];
                    style_block += style + ":" + this.search_field.css(style) + ";";
                }
                div = $("<div />", {
                    style: style_block
                });
                div.text(this.search_field.val());
                $("body").append(div);
                w = div.width() + 25;
                div.remove();
                if (!this.f_width) {
                    this.f_width = this.container.outerWidth();
                }
                if (w > this.f_width - 10) {
                    w = this.f_width - 10;
                }
                return this.search_field.css({
                    width: w + "px"
                });
            }
        };
        Chosen.prototype.generate_random_id = function() {
            var string;
            string = "sel" + this.generate_random_char() + this.generate_random_char() + this.generate_random_char();
            while ($("#" + string).length > 0) {
                string += this.generate_random_char();
            }
            return string;
        };
        return Chosen;
    }(AbstractChosen);
    root.Chosen = Chosen;
}).call(this);

/*global jQuery */
/*jshint multistr:true browser:true */
/*!
* FitVids 1.0
*
* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com
* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/
* Released under the WTFPL license - http://sam.zoy.org/wtfpl/
*
* Date: Thu Sept 01 18:00:00 2011 -0500
*/
(function($) {
    "use strict";
    $.fn.fitVids = function(options) {
        var settings = {
            customSelector: null
        };
        if (!document.getElementById("fit-vids-style")) {
            var div = document.createElement("div"), ref = document.getElementsByTagName("base")[0] || document.getElementsByTagName("script")[0], cssStyles = "&shy;<style>.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}</style>";
            div.className = "fit-vids-style";
            div.id = "fit-vids-style";
            div.style.display = "none";
            div.innerHTML = cssStyles;
            ref.parentNode.insertBefore(div, ref);
        }
        if (options) {
            $.extend(settings, options);
        }
        return this.each(function() {
            var selectors = [ "iframe[src*='player.vimeo.com']", "iframe[src*='youtube.com']", "iframe[src*='youtube-nocookie.com']", "iframe[src*='kickstarter.com'][src*='video.html']", "object", "embed" ];
            if (settings.customSelector) {
                selectors.push(settings.customSelector);
            }
            var $allVideos = $(this).find(selectors.join(","));
            $allVideos = $allVideos.not("object object");
            // SwfObj conflict patch
            $allVideos.each(function() {
                var $this = $(this);
                if (this.tagName.toLowerCase() === "embed" && $this.parent("object").length || $this.parent(".fluid-width-video-wrapper").length) {
                    return;
                }
                var height = this.tagName.toLowerCase() === "object" || $this.attr("height") && !isNaN(parseInt($this.attr("height"), 10)) ? parseInt($this.attr("height"), 10) : $this.height(), width = !isNaN(parseInt($this.attr("width"), 10)) ? parseInt($this.attr("width"), 10) : $this.width(), aspectRatio = height / width;
                if (!$this.attr("id")) {
                    var videoID = "fitvid" + Math.floor(Math.random() * 999999);
                    $this.attr("id", videoID);
                }
                $this.wrap('<div class="fluid-width-video-wrapper"></div>').parent(".fluid-width-video-wrapper").css("padding-top", aspectRatio * 100 + "%");
                $this.removeAttr("height").removeAttr("width");
            });
        });
    };
})(window.jQuery || window.Zepto);

(function(window, document, $) {
    var isInputSupported = "placeholder" in document.createElement("input"), isTextareaSupported = "placeholder" in document.createElement("textarea"), prototype = $.fn, valHooks = $.valHooks, hooks, placeholder;
    if (isInputSupported && isTextareaSupported) {
        placeholder = prototype.placeholder = function() {
            return this;
        };
        placeholder.input = placeholder.textarea = true;
    } else {
        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this.filter((isInputSupported ? "textarea" : ":input") + "[placeholder]").not(".placeholder").bind({
                "focus.placeholder": clearPlaceholder,
                "blur.placeholder": setPlaceholder
            }).data("placeholder-enabled", true).trigger("blur.placeholder");
            return $this;
        };
        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;
        hooks = {
            get: function(element) {
                var $element = $(element);
                return $element.data("placeholder-enabled") && $element.hasClass("placeholder") ? "" : element.value;
            },
            set: function(element, value) {
                var $element = $(element);
                if (!$element.data("placeholder-enabled")) {
                    return element.value = value;
                }
                if (value == "") {
                    element.value = value;
                    // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                    if (element != document.activeElement) {
                        // We cant use `triggerHandler` here because of dummy text/password inputs :(
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass("placeholder")) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                return $element;
            }
        };
        isInputSupported || (valHooks.input = hooks);
        isTextareaSupported || (valHooks.textarea = hooks);
        $(function() {
            // Look for forms
            $(document).delegate("form", "submit.placeholder", function() {
                // Clear the placeholder values so they dont get submitted
                var $inputs = $(".placeholder", this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });
        // Clear placeholder values upon page reload
        $(window).bind("beforeunload.placeholder", function() {
            $(".placeholder").each(function() {
                this.value = "";
            });
        });
    }
    function args(elem) {
        // Return an object of element attributes
        var newAttrs = {}, rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }
    function clearPlaceholder(event, value) {
        var input = this, $input = $(input);
        if (input.value == $input.attr("placeholder") && $input.hasClass("placeholder")) {
            if ($input.data("placeholder-password")) {
                $input = $input.hide().next().show().attr("id", $input.removeAttr("id").data("placeholder-id"));
                // If `clearPlaceholder` was called from `$.valHooks.input.set`
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = "";
                $input.removeClass("placeholder");
                input == document.activeElement && input.select();
            }
        }
    }
    function setPlaceholder() {
        var $replacement, input = this, $input = $(input), $origInput = $input, id = this.id;
        if (input.value == "") {
            if (input.type == "password") {
                if (!$input.data("placeholder-textinput")) {
                    try {
                        $replacement = $input.clone().attr({
                            type: "text"
                        });
                    } catch (e) {
                        $replacement = $("<input>").attr($.extend(args(this), {
                            type: "text"
                        }));
                    }
                    $replacement.removeAttr("name").data({
                        "placeholder-password": true,
                        "placeholder-id": id
                    }).bind("focus.placeholder", clearPlaceholder);
                    $input.data({
                        "placeholder-textinput": $replacement,
                        "placeholder-id": id
                    }).before($replacement);
                }
                $input = $input.removeAttr("id").hide().prev().attr("id", id).show();
            }
            $input.addClass("placeholder");
            $input[0].value = $input.attr("placeholder");
        } else {
            $input.removeClass("placeholder");
        }
    }
})(this, document, jQuery);

/*!
 * hoverIntent r7 // 2013.03.11 // jQuery 1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2013 Brian Cherne
 */
/* hoverIntent is similar to jQuery's built-in "hover" method except that
 * instead of firing the handlerIn function immediately, hoverIntent checks
 * to see if the user's mouse has slowed down (beneath the sensitivity
 * threshold) before firing the event. The handlerOut function is only
 * called after a matching handlerIn.
 *
 * // basic usage ... just like .hover()
 * .hoverIntent( handlerIn, handlerOut )
 * .hoverIntent( handlerInOut )
 *
 * // basic usage ... with event delegation!
 * .hoverIntent( handlerIn, handlerOut, selector )
 * .hoverIntent( handlerInOut, selector )
 *
 * // using a basic configuration object
 * .hoverIntent( config )
 *
 * @param  handlerIn   function OR configuration object
 * @param  handlerOut  function OR selector for delegation OR undefined
 * @param  selector    selector OR undefined
 * @author Brian Cherne <brian(at)cherne(dot)net>
 */
(function($) {
    $.fn.hoverIntent = function(handlerIn, handlerOut, selector) {
        // default configuration values
        var cfg = {
            interval: 100,
            sensitivity: 7,
            timeout: 0
        };
        if (typeof handlerIn === "object") {
            cfg = $.extend(cfg, handlerIn);
        } else if ($.isFunction(handlerOut)) {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerOut,
                selector: selector
            });
        } else {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerIn,
                selector: handlerOut
            });
        }
        // instantiate variables
        // cX, cY = current X and Y position of mouse, updated by mousemove event
        // pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
        var cX, cY, pX, pY;
        // A private function for getting mouse position
        var track = function(ev) {
            cX = ev.pageX;
            cY = ev.pageY;
        };
        // A private function for comparing current and previous mouse position
        var compare = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            // compare mouse positions to see if they've crossed the threshold
            if (Math.abs(pX - cX) + Math.abs(pY - cY) < cfg.sensitivity) {
                $(ob).off("mousemove.hoverIntent", track);
                // set hoverIntent state to true (so mouseOut can be called)
                ob.hoverIntent_s = 1;
                return cfg.over.apply(ob, [ ev ]);
            } else {
                // set previous coordinates for next time
                pX = cX;
                pY = cY;
                // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
                ob.hoverIntent_t = setTimeout(function() {
                    compare(ev, ob);
                }, cfg.interval);
            }
        };
        // A private function for delaying the mouseOut function
        var delay = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            ob.hoverIntent_s = 0;
            return cfg.out.apply(ob, [ ev ]);
        };
        // A private function for handling mouse 'hovering'
        var handleHover = function(e) {
            // copy objects to be passed into t (required for event object to be passed in IE)
            var ev = jQuery.extend({}, e);
            var ob = this;
            // cancel hoverIntent timer if it exists
            if (ob.hoverIntent_t) {
                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            }
            // if e.type == "mouseenter"
            if (e.type == "mouseenter") {
                // set "previous" X and Y position based on initial entry point
                pX = ev.pageX;
                pY = ev.pageY;
                // update "current" X and Y position based on mousemove
                $(ob).on("mousemove.hoverIntent", track);
                // start polling interval (self-calling timeout) to compare mouse coordinates over time
                if (ob.hoverIntent_s != 1) {
                    ob.hoverIntent_t = setTimeout(function() {
                        compare(ev, ob);
                    }, cfg.interval);
                }
            } else {
                // unbind expensive mousemove event
                $(ob).off("mousemove.hoverIntent", track);
                // if hoverIntent state is true, then call the mouseOut function after the specified delay
                if (ob.hoverIntent_s == 1) {
                    ob.hoverIntent_t = setTimeout(function() {
                        delay(ev, ob);
                    }, cfg.timeout);
                }
            }
        };
        // listen for mouseenter and mouseleave
        return this.on({
            "mouseenter.hoverIntent": handleHover,
            "mouseleave.hoverIntent": handleHover
        }, cfg.selector);
    };
})(jQuery);

/*! Picturefill - Responsive Images that work today. (and mimic the proposed Picture element with span elements). Author: Scott Jehl, Filament Group, 2012 | License: MIT/GPLv2 */
(function(w) {
    // Enable strict mode
    "use strict";
    w.picturefill = function() {
        var ps = w.document.getElementsByTagName("span");
        // Loop the pictures
        for (var i = 0, il = ps.length; i < il; i++) {
            if (ps[i].getAttribute("data-picture") !== null) {
                var sources = ps[i].getElementsByTagName("span"), matches = [];
                // See if which sources match
                for (var j = 0, jl = sources.length; j < jl; j++) {
                    var media = sources[j].getAttribute("data-media");
                    // if there's no media specified, OR w.matchMedia is supported 
                    if (!media || w.matchMedia && w.matchMedia(media).matches) {
                        matches.push(sources[j]);
                    }
                }
                // Find any existing img element in the picture element
                var picImg = ps[i].getElementsByTagName("img")[0];
                if (matches.length) {
                    var matchedEl = matches.pop();
                    if (!picImg || picImg.parentNode.nodeName === "NOSCRIPT") {
                        picImg = w.document.createElement("img");
                        picImg.alt = ps[i].getAttribute("data-alt");
                    } else if (matchedEl === picImg.parentNode) {
                        // Skip further actions if the correct image is already in place
                        continue;
                    }
                    picImg.src = matchedEl.getAttribute("data-src");
                    matchedEl.appendChild(picImg);
                    picImg.removeAttribute("width");
                    picImg.removeAttribute("height");
                } else if (picImg) {
                    picImg.parentNode.removeChild(picImg);
                }
            }
        }
    };
    // Run on resize and domready (w.load as a fallback)
    if (w.addEventListener) {
        w.addEventListener("resize", w.picturefill, false);
        w.addEventListener("DOMContentLoaded", function() {
            w.picturefill();
            // Run once only
            w.removeEventListener("load", w.picturefill, false);
        }, false);
        w.addEventListener("load", w.picturefill, false);
    } else if (w.attachEvent) {
        w.attachEvent("onload", w.picturefill);
    }
})(this);

/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */
window.matchMedia || (window.matchMedia = function() {
    "use strict";
    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = window.styleMedia || window.media;
    // For those that don't support matchMedium
    if (!styleMedia) {
        var style = document.createElement("style"), script = document.getElementsByTagName("script")[0], info = null;
        style.type = "text/css";
        style.id = "matchmediajs-test";
        script.parentNode.insertBefore(style, script);
        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = "getComputedStyle" in window && window.getComputedStyle(style, null) || style.currentStyle;
        styleMedia = {
            matchMedium: function(media) {
                var text = "@media " + media + "{ #matchmediajs-test { width: 1px; } }";
                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }
                // Test if media query is true or false
                return info.width === "1px";
            }
        };
    }
    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || "all"),
            media: media || "all"
        };
    };
}());

(function(name, context, factory) {
    var matchMedia = context.matchMedia;
    if (typeof module !== "undefined" && module.exports) {
        module.exports = factory(matchMedia);
    } else if (typeof define === "function" && define.amd) {
        define(function() {
            return context[name] = factory(matchMedia);
        });
    } else {
        context[name] = factory(matchMedia);
    }
})("enquire", this, function(matchMedia) {
    "use strict";
    /*jshint unused:false */
    /**
     * Helper function for iterating over a collection
     *
     * @param collection
     * @param fn
     */
    function each(collection, fn) {
        var i = 0, length = collection.length, cont;
        for (i; i < length; i++) {
            cont = fn(collection[i], i);
            if (cont === false) {
                break;
            }
        }
    }
    /**
     * Helper function for determining whether target object is an array
     *
     * @param target the object under test
     * @return {Boolean} true if array, false otherwise
     */
    function isArray(target) {
        return Object.prototype.toString.apply(target) === "[object Array]";
    }
    /**
     * Helper function for determining whether target object is a function
     *
     * @param target the object under test
     * @return {Boolean} true if function, false otherwise
     */
    function isFunction(target) {
        return typeof target === "function";
    }
    /**
     * Delegate to handle a media query being matched and unmatched.
     *
     * @param {object} options
     * @param {function} options.match callback for when the media query is matched
     * @param {function} [options.unmatch] callback for when the media query is unmatched
     * @param {function} [options.setup] one-time callback triggered the first time a query is matched
     * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?
     * @constructor
     */
    function QueryHandler(options) {
        this.options = options;
        !options.deferSetup && this.setup();
    }
    QueryHandler.prototype = {
        /**
         * coordinates setup of the handler
         *
         * @function
         */
        setup: function() {
            if (this.options.setup) {
                this.options.setup();
            }
            this.initialised = true;
        },
        /**
         * coordinates setup and triggering of the handler
         *
         * @function
         */
        on: function() {
            !this.initialised && this.setup();
            this.options.match && this.options.match();
        },
        /**
         * coordinates the unmatch event for the handler
         *
         * @function
         */
        off: function() {
            this.options.unmatch && this.options.unmatch();
        },
        /**
         * called when a handler is to be destroyed.
         * delegates to the destroy or unmatch callbacks, depending on availability.
         *
         * @function
         */
        destroy: function() {
            this.options.destroy ? this.options.destroy() : this.off();
        },
        /**
         * determines equality by reference.
         * if object is supplied compare options, if function, compare match callback
         *
         * @function
         * @param {object || function} [target] the target for comparison
         */
        equals: function(target) {
            return this.options === target || this.options.match === target;
        }
    };
    /**
     * Represents a single media query, manages it's state and registered handlers for this query
     *
     * @constructor
     * @param {string} query the media query string
     * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design
     */
    function MediaQuery(query, isUnconditional) {
        this.query = query;
        this.isUnconditional = isUnconditional;
        this.handlers = [];
        this.mql = matchMedia(query);
        var self = this;
        this.listener = function(mql) {
            self.mql = mql;
            self.assess();
        };
        this.mql.addListener(this.listener);
    }
    MediaQuery.prototype = {
        /**
         * add a handler for this query, triggering if already active
         *
         * @param {object} handler
         * @param {function} handler.match callback for when query is activated
         * @param {function} [handler.unmatch] callback for when query is deactivated
         * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
         * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
         */
        addHandler: function(handler) {
            var qh = new QueryHandler(handler);
            this.handlers.push(qh);
            this.matches() && qh.on();
        },
        /**
         * removes the given handler from the collection, and calls it's destroy methods
         * 
         * @param {object || function} handler the handler to remove
         */
        removeHandler: function(handler) {
            var handlers = this.handlers;
            each(handlers, function(h, i) {
                if (h.equals(handler)) {
                    h.destroy();
                    return !handlers.splice(i, 1);
                }
            });
        },
        /**
         * Determine whether the media query should be considered a match
         * 
         * @return {Boolean} true if media query can be considered a match, false otherwise
         */
        matches: function() {
            return this.mql.matches || this.isUnconditional;
        },
        /**
         * Clears all handlers and unbinds events
         */
        clear: function() {
            each(this.handlers, function(handler) {
                handler.destroy();
            });
            this.mql.removeListener(this.listener);
            this.handlers.length = 0;
        },
        /*
         * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
         */
        assess: function() {
            var action = this.matches() ? "on" : "off";
            each(this.handlers, function(handler) {
                handler[action]();
            });
        }
    };
    /**
     * Allows for registration of query handlers.
     * Manages the query handler's state and is responsible for wiring up browser events
     *
     * @constructor
     */
    function MediaQueryDispatch() {
        if (!matchMedia) {
            throw new Error("matchMedia not present, legacy browsers require a polyfill");
        }
        this.queries = {};
        this.browserIsIncapable = !matchMedia("only all").matches;
    }
    MediaQueryDispatch.prototype = {
        /**
         * Registers a handler for the given media query
         *
         * @param {string} q the media query
         * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
         * @param {function} options.match fired when query matched
         * @param {function} [options.unmatch] fired when a query is no longer matched
         * @param {function} [options.setup] fired when handler first triggered
         * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
         * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
         */
        register: function(q, options, shouldDegrade) {
            var queries = this.queries, isUnconditional = shouldDegrade && this.browserIsIncapable;
            if (!queries[q]) {
                queries[q] = new MediaQuery(q, isUnconditional);
            }
            //normalise to object in an array
            if (isFunction(options)) {
                options = {
                    match: options
                };
            }
            if (!isArray(options)) {
                options = [ options ];
            }
            each(options, function(handler) {
                queries[q].addHandler(handler);
            });
            return this;
        },
        /**
         * unregisters a query and all it's handlers, or a specific handler for a query
         *
         * @param {string} q the media query to target
         * @param {object || function} [handler] specific handler to unregister
         */
        unregister: function(q, handler) {
            var query = this.queries[q];
            if (query) {
                if (handler) {
                    query.removeHandler(handler);
                } else {
                    query.clear();
                    delete this.queries[q];
                }
            }
            return this;
        }
    };
    return new MediaQueryDispatch();
});

(function($, window, document, undefined) {
    var pluginName = "nivoLightbox", defaults = {
        effect: "fade",
        theme: "default",
        keyboardNav: true,
        clickOverlayToClose: true,
        onInit: function() {},
        beforeShowLightbox: function() {},
        afterShowLightbox: function(lightbox) {},
        beforeHideLightbox: function() {},
        afterHideLightbox: function() {},
        onPrev: function(element) {},
        onNext: function(element) {},
        errorMessage: "The requested content cannot be loaded. Please try again later."
    };
    function NivoLightbox(element, options) {
        this.el = element;
        this.$el = $(this.el);
        this.options = $.extend({}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
    }
    NivoLightbox.prototype = {
        init: function() {
            var $this = this;
            // Need this so we don't use CSS transitions in mobile
            if (!$("html").hasClass("nivo-lightbox-notouch")) $("html").addClass("nivo-lightbox-notouch");
            if ("ontouchstart" in document) $("html").removeClass("nivo-lightbox-notouch");
            // Setup the click
            this.$el.on("click", function(e) {
                $this.showLightbox(e);
            });
            // keyboardNav
            if (this.options.keyboardNav) {
                $("body").off("keyup").on("keyup", function(e) {
                    var code = e.keyCode ? e.keyCode : e.which;
                    // Escape
                    if (code == 27) $this.destructLightbox();
                    // Left
                    if (code == 37) $(".nivo-lightbox-prev").trigger("click");
                    // Right
                    if (code == 39) $(".nivo-lightbox-next").trigger("click");
                });
            }
            this.options.onInit.call(this);
        },
        showLightbox: function(e) {
            var $this = this, currentLink = this.$el;
            // Check content
            var check = this.checkContent(currentLink);
            if (!check) return;
            e.preventDefault();
            this.options.beforeShowLightbox.call(this);
            var lightbox = this.constructLightbox();
            if (!lightbox) return;
            var content = lightbox.find(".nivo-lightbox-content");
            if (!content) return;
            $("body").addClass("nivo-lightbox-body-effect-" + this.options.effect);
            this.processContent(content, currentLink);
            // Nav
            if (this.$el.attr("data-lightbox-gallery")) {
                var galleryItems = $('[data-lightbox-gallery="' + this.$el.attr("data-lightbox-gallery") + '"]');
                $(".nivo-lightbox-nav").show();
                // Prev
                $(".nivo-lightbox-prev").off("click").on("click", function(e) {
                    e.preventDefault();
                    var index = galleryItems.index(currentLink);
                    currentLink = galleryItems.eq(index - 1);
                    if (!$(currentLink).length) currentLink = galleryItems.last();
                    $this.processContent(content, currentLink);
                    $this.options.onPrev.call(this, [ currentLink ]);
                });
                // Next
                $(".nivo-lightbox-next").off("click").on("click", function(e) {
                    e.preventDefault();
                    var index = galleryItems.index(currentLink);
                    currentLink = galleryItems.eq(index + 1);
                    if (!$(currentLink).length) currentLink = galleryItems.first();
                    $this.processContent(content, currentLink);
                    $this.options.onNext.call(this, [ currentLink ]);
                });
            }
            setTimeout(function() {
                lightbox.addClass("nivo-lightbox-open");
                $this.options.afterShowLightbox.call(this, [ lightbox ]);
            }, 1);
        },
        checkContent: function(link) {
            var $this = this, href = link.attr("href"), video = href.match(/(youtube|youtu|vimeo)\.(com|be)\/(watch\?v=([\w-]+)|([\w-]+))/);
            if (href.match(/\.(jpeg|jpg|gif|png)$/i) !== null) {
                return true;
            } else if (video) {
                return true;
            } else if (link.attr("data-lightbox-type") == "ajax") {
                return true;
            } else if (href.substring(0, 1) == "#" && link.attr("data-lightbox-type") == "inline") {
                return true;
            } else if (link.attr("data-lightbox-type") == "iframe") {
                return true;
            }
            return false;
        },
        processContent: function(content, link) {
            var $this = this, href = link.attr("href"), video = href.match(/(youtube|youtu|vimeo)\.(com|be)\/(watch\?v=([\w-]+)|([\w-]+))/);
            content.html("").addClass("nivo-lightbox-loading");
            // Is HiDPI?
            if (this.isHidpi() && link.attr("data-lightbox-hidpi")) {
                href = link.attr("data-lightbox-hidpi");
            }
            // Image
            if (href.match(/\.(jpeg|jpg|gif|png)$/i) !== null) {
                var img = $("<img>", {
                    src: href
                });
                img.one("load", function() {
                    var wrap = $('<div class="nivo-lightbox-image" />');
                    wrap.append(img);
                    content.html(wrap).removeClass("nivo-lightbox-loading");
                    // Vertically center images
                    wrap.css({
                        "line-height": $(".nivo-lightbox-content").height() + "px",
                        height: $(".nivo-lightbox-content").height() + "px"
                    });
                    $(window).resize(function() {
                        wrap.css({
                            "line-height": $(".nivo-lightbox-content").height() + "px",
                            height: $(".nivo-lightbox-content").height() + "px"
                        });
                    });
                }).each(function() {
                    if (this.complete) $(this).load();
                });
                img.error(function() {
                    var wrap = $('<div class="nivo-lightbox-error"><p>' + $this.options.errorMessage + "</p></div>");
                    content.html(wrap).removeClass("nivo-lightbox-loading");
                });
            } else if (video) {
                var src = "", classTerm = "nivo-lightbox-video";
                if (video[1] == "youtube") {
                    src = "http://www.youtube.com/embed/" + video[4];
                    classTerm = "nivo-lightbox-youtube";
                }
                if (video[1] == "youtu") {
                    src = "http://www.youtube.com/embed/" + video[3];
                    classTerm = "nivo-lightbox-youtube";
                }
                if (video[1] == "vimeo") {
                    src = "http://player.vimeo.com/video/" + video[3];
                    classTerm = "nivo-lightbox-vimeo";
                }
                if (src) {
                    var iframeVideo = $("<iframe>", {
                        src: src,
                        "class": classTerm,
                        frameborder: 0,
                        vspace: 0,
                        hspace: 0,
                        scrolling: "auto"
                    });
                    content.html(iframeVideo);
                    iframeVideo.load(function() {
                        content.removeClass("nivo-lightbox-loading");
                    });
                }
            } else if (link.attr("data-lightbox-type") == "ajax") {
                $.ajax({
                    url: href,
                    cache: false,
                    success: function(data) {
                        var wrap = $('<div class="nivo-lightbox-ajax" />');
                        wrap.append(data);
                        content.html(wrap).removeClass("nivo-lightbox-loading");
                        // Vertically center html
                        if (wrap.outerHeight() < content.height()) {
                            wrap.css({
                                position: "relative",
                                top: "50%",
                                "margin-top": -(wrap.outerHeight() / 2) + "px"
                            });
                        }
                        $(window).resize(function() {
                            if (wrap.outerHeight() < content.height()) {
                                wrap.css({
                                    position: "relative",
                                    top: "50%",
                                    "margin-top": -(wrap.outerHeight() / 2) + "px"
                                });
                            }
                        });
                    },
                    error: function() {
                        var wrap = $('<div class="nivo-lightbox-error"><p>' + $this.options.errorMessage + "</p></div>");
                        content.html(wrap).removeClass("nivo-lightbox-loading");
                    }
                });
            } else if (href.substring(0, 1) == "#" && link.attr("data-lightbox-type") == "inline") {
                if ($(href).length) {
                    var wrap = $('<div class="nivo-lightbox-inline" />');
                    wrap.append($(href).clone().show());
                    content.html(wrap).removeClass("nivo-lightbox-loading");
                    // Vertically center html
                    if (wrap.outerHeight() < content.height()) {
                        wrap.css({
                            position: "relative",
                            top: "50%",
                            "margin-top": -(wrap.outerHeight() / 2) + "px"
                        });
                    }
                    $(window).resize(function() {
                        if (wrap.outerHeight() < content.height()) {
                            wrap.css({
                                position: "relative",
                                top: "50%",
                                "margin-top": -(wrap.outerHeight() / 2) + "px"
                            });
                        }
                    });
                } else {
                    var wrapError = $('<div class="nivo-lightbox-error"><p>' + $this.options.errorMessage + "</p></div>");
                    content.html(wrapError).removeClass("nivo-lightbox-loading");
                }
            } else if (link.attr("data-lightbox-type") == "iframe") {
                var iframe = $("<iframe>", {
                    src: href,
                    "class": "nivo-lightbox-item",
                    frameborder: 0,
                    vspace: 0,
                    hspace: 0,
                    scrolling: "auto"
                });
                content.html(iframe);
                iframe.load(function() {
                    content.removeClass("nivo-lightbox-loading");
                });
            } else {
                return false;
            }
            // Set the title
            if (link.attr("title")) {
                var titleWrap = $("<span>", {
                    "class": "nivo-lightbox-title"
                });
                titleWrap.text(link.attr("title"));
                $(".nivo-lightbox-title-wrap").html(titleWrap);
            } else {
                $(".nivo-lightbox-title-wrap").html("");
            }
        },
        constructLightbox: function() {
            if ($(".nivo-lightbox-overlay").length) return $(".nivo-lightbox-overlay");
            var overlay = $("<div>", {
                "class": "nivo-lightbox-overlay nivo-lightbox-theme-" + this.options.theme + " nivo-lightbox-effect-" + this.options.effect
            });
            var wrap = $("<div>", {
                "class": "nivo-lightbox-wrap"
            });
            var content = $("<div>", {
                "class": "nivo-lightbox-content"
            });
            var nav = $('<a href="#" class="nivo-lightbox-nav nivo-lightbox-prev">Previous</a><a href="#" class="nivo-lightbox-nav nivo-lightbox-next">Next</a>');
            var close = $('<a href="#" class="nivo-lightbox-close" title="Close">Close</a>');
            var title = $("<div>", {
                "class": "nivo-lightbox-title-wrap"
            });
            var isMSIE = /*@cc_on!@*/ 0;
            if (isMSIE) overlay.addClass("nivo-lightbox-ie");
            wrap.append(content);
            wrap.append(title);
            overlay.append(wrap);
            overlay.append(nav);
            overlay.append(close);
            $("body").append(overlay);
            var $this = this;
            if ($this.options.clickOverlayToClose) {
                overlay.on("click", function(e) {
                    if (e.target === this || $(e.target).hasClass("nivo-lightbox-content") || $(e.target).hasClass("nivo-lightbox-image")) {
                        $this.destructLightbox();
                    }
                });
            }
            close.on("click", function(e) {
                e.preventDefault();
                $this.destructLightbox();
            });
            return overlay;
        },
        destructLightbox: function() {
            var $this = this;
            this.options.beforeHideLightbox.call(this);
            $(".nivo-lightbox-overlay").removeClass("nivo-lightbox-open");
            $(".nivo-lightbox-nav").hide();
            $("body").removeClass("nivo-lightbox-body-effect-" + $this.options.effect);
            // For IE
            var isMSIE = /*@cc_on!@*/ 0;
            if (isMSIE) {
                $(".nivo-lightbox-overlay iframe").attr("src", " ");
                $(".nivo-lightbox-overlay iframe").remove();
            }
            // Remove click handlers
            $(".nivo-lightbox-prev").off("click");
            $(".nivo-lightbox-next").off("click");
            // Empty content (for videos)
            $(".nivo-lightbox-content").empty();
            this.options.afterHideLightbox.call(this);
        },
        isHidpi: function() {
            var mediaQuery = "(-webkit-min-device-pixel-ratio: 1.5),                              (min--moz-device-pixel-ratio: 1.5),                              (-o-min-device-pixel-ratio: 3/2),                              (min-resolution: 1.5dppx)";
            if (window.devicePixelRatio > 1) return true;
            if (window.matchMedia && window.matchMedia(mediaQuery).matches) return true;
            return false;
        }
    };
    $.fn[pluginName] = function(options) {
        return this.each(function() {
            if (!$.data(this, pluginName)) {
                $.data(this, pluginName, new NivoLightbox(this, options));
            }
        });
    };
})(jQuery, window, document);

/*
 * RoyalSlider
 *
 * @version 9.4.6:
 *
 * Copyright 2011-2012, Dmitry Semenov
 *
 */
(function($) {
    if (!$.rsModules) {
        $.rsModules = {
            uid: 0
        };
    }
    function RoyalSlider(element, options) {
        var i, self = this, ua = navigator.userAgent.toLowerCase();
        self.uid = $.rsModules.uid++;
        self.ns = ".rs" + self.uid;
        // unique namespace for events
        // feature detection, some ideas taken from Modernizr
        var tempStyle = document.createElement("div").style, vendors = [ "webkit", "Moz", "ms", "O" ], vendor = "", lastTime = 0, tempV;
        for (i = 0; i < vendors.length; i++) {
            tempV = vendors[i];
            if (!vendor && tempV + "Transform" in tempStyle) {
                vendor = tempV;
            }
            tempV = tempV.toLowerCase();
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = window[tempV + "RequestAnimationFrame"];
                window.cancelAnimationFrame = window[tempV + "CancelAnimationFrame"] || window[tempV + "CancelRequestAnimationFrame"];
            }
        }
        // requestAnimationFrame polyfill by Erik Mller
        // fixes from Paul Irish and Tino Zijdel
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
        self.isIPAD = ua.match(/(ipad)/);
        // browser UA sniffing, sadly still required
        var uaMatch = function(ua) {
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
        var matched = uaMatch(ua);
        var br = {};
        if (matched.browser) {
            br[matched.browser] = true;
            br.version = matched.version;
        }
        if (br.chrome) {
            br.webkit = true;
        }
        self._browser = br;
        self.slider = $(element);
        // DOM reference
        self.ev = $(self);
        // event object
        self._doc = $(document);
        self.st = $.extend({}, $.fn.royalSlider.defaults, options);
        self._currAnimSpeed = self.st.transitionSpeed;
        self._minPosOffset = 0;
        if (self.st.allowCSS3) {
            if (!br.webkit || self.st.allowCSS3OnWebkit) {
                var bT = vendor + (vendor ? "T" : "t");
                self._useCSS3Transitions = bT + "ransform" in tempStyle && bT + "ransition" in tempStyle;
                if (self._useCSS3Transitions) {
                    self._use3dTransform = vendor + (vendor ? "P" : "p") + "erspective" in tempStyle;
                }
            }
        }
        vendor = vendor.toLowerCase();
        self._vendorPref = "-" + vendor + "-";
        self._slidesHorizontal = self.st.slidesOrientation === "vertical" ? false : true;
        self._reorderProp = self._slidesHorizontal ? "left" : "top";
        self._sizeProp = self._slidesHorizontal ? "width" : "height";
        self._prevNavItemId = -1;
        self._isMove = self.st.transitionType === "fade" ? false : true;
        if (!self._isMove) {
            self.st.sliderDrag = false;
            self._fadeZIndex = 10;
        }
        self._opacityCSS = "z-index:0; display:none; opacity:0;";
        self._newSlideId = 0;
        self._sPosition = 0;
        self._nextSlidePos = 0;
        // init modules
        $.each($.rsModules, function(helper, opts) {
            if (helper !== "uid") opts.call(self);
        });
        // parse all slides
        self.slides = [];
        self._idCount = 0;
        var returnVal;
        var ts = self.st.slides ? $(self.st.slides) : self.slider.children().detach();
        ts.each(function() {
            self._parseNode(this, true);
        });
        if (self.st.randomizeSlides) {
            self.slides.sort(function() {
                return .5 - Math.random();
            });
        }
        self.numSlides = self.slides.length;
        self._refreshNumPreloadImages();
        if (!self.st.startSlideId) {
            self.st.startSlideId = 0;
        } else if (self.st.startSlideId > self.numSlides - 1) {
            self.st.startSlideId = self.numSlides - 1;
        }
        self._newSlideId = self.staticSlideId = self.currSlideId = self._realId = self.st.startSlideId;
        self.currSlide = self.slides[self.currSlideId];
        self._accelerationPos = 0;
        self.msTouch = false;
        self.slider.addClass((self._slidesHorizontal ? "rsHor" : "rsVer") + (self._isMove ? "" : " rsFade"));
        var sliderHTML = '<div class="rsOverflow"><div class="rsContainer">';
        self.slidesSpacing = self.st.slidesSpacing;
        self._slideSize = (self._slidesHorizontal ? self.slider.width() : self.slider.height()) + self.st.slidesSpacing;
        self._preload = Boolean(self._numPreloadImages > 0);
        if (self.numSlides <= 1) {
            self._loop = false;
        }
        var loopHelpers = self._loop && self._isMove ? self.numSlides === 2 ? 1 : 2 : 0;
        self._loopHelpers = loopHelpers;
        self._maxImages = self.numSlides < 6 ? self.numSlides : 6;
        self._currBlockIndex = 0;
        self._idOffset = 0;
        self.slidesJQ = [];
        for (i = 0; i < self.numSlides; i++) {
            self.slidesJQ.push($(createItemHTML(i)));
        }
        self._sliderOverflow = sliderHTML = $(sliderHTML + "</div></div>");
        var addCursors = function() {
            if (self.st.sliderDrag) {
                self._hasDrag = true;
                if (br.msie || br.opera) {
                    self._grabCursor = self._grabbingCursor = "move";
                } else if (br.mozilla) {
                    self._grabCursor = "-moz-grab";
                    self._grabbingCursor = "-moz-grabbing";
                } else if (br.webkit && navigator.platform.indexOf("Mac") != -1) {
                    self._grabCursor = "-webkit-grab";
                    self._grabbingCursor = "-webkit-grabbing";
                }
                self._setGrabCursor();
            }
        };
        var rsNS = self.ns;
        var addEventNames = function(pref, down, move, up, cancel) {
            self._downEvent = pref + down + rsNS;
            self._moveEvent = pref + move + rsNS;
            self._upEvent = pref + up + rsNS;
            if (cancel) self._cancelEvent = pref + cancel + rsNS;
        };
        // ie10
        self.msEnabled = window.navigator.msPointerEnabled;
        if (self.msEnabled) {
            self.msTouch = Boolean(window.navigator.msMaxTouchPoints > 1);
            self.hasTouch = false;
            self._lastItemFriction = .2;
            addEventNames("MSPointer", "Down", "Move", "Up", "Cancel");
        } else {
            addEventNames("mouse", "down", "move", "up", "up");
            if ("ontouchstart" in window || "createTouch" in document) {
                self.hasTouch = true;
                self._downEvent += " touchstart" + rsNS;
                self._moveEvent += " touchmove" + rsNS;
                self._upEvent += " touchend" + rsNS;
                self._cancelEvent += " touchcancel" + rsNS;
                self._lastItemFriction = .5;
                if (self.st.sliderTouch) {
                    self._hasDrag = true;
                }
            } else {
                self.hasTouch = false;
                self._lastItemFriction = .2;
            }
        }
        addCursors();
        self.slider.html(sliderHTML);
        self._controlsContainer = self.st.controlsInside ? self._sliderOverflow : self.slider;
        self._slidesContainer = self._sliderOverflow.children(".rsContainer");
        if (self.msEnabled) {
            self._slidesContainer.css("-ms-touch-action", self._slidesHorizontal ? "pan-y" : "pan-x");
        }
        self._preloader = $('<div class="rsPreloader"></div>');
        var slides = self._slidesContainer.children(".rsSlide");
        self._currHolder = self.slidesJQ[self.currSlideId];
        self._selectedSlideHolder = 0;
        function createItemHTML(i, className) {
            return '<div style="' + (self._isMove ? "" : i !== self.currSlideId ? self._opacityCSS : "z-index:0;") + '" class="rsSlide ' + (className || "") + '"></div>';
        }
        if (self._useCSS3Transitions) {
            // some constants for CSS3
            self._TP = "transition-property";
            self._TD = "transition-duration";
            self._TTF = "transition-timing-function";
            self._yProp = self._xProp = self._vendorPref + "transform";
            if (self._use3dTransform) {
                if (br.webkit) {
                    self.slider.addClass("rsWebkit3d");
                }
                self._tPref1 = "translate3d(";
                self._tPref2 = "px, ";
                self._tPref3 = "px, 0px)";
            } else {
                self._tPref1 = "translate(";
                self._tPref2 = "px, ";
                self._tPref3 = "px)";
            }
            if (!self._isMove) {
                var animObj = {};
                animObj[self._vendorPref + self._TP] = "opacity";
                animObj[self._vendorPref + self._TD] = self.st.transitionSpeed + "ms";
                animObj[self._vendorPref + self._TTF] = self.st.css3easeInOut;
                slides.css(animObj);
            } else {
                self._slidesContainer[self._vendorPref + self._TP] = self._vendorPref + "transform";
            }
        } else {
            self._xProp = "left";
            self._yProp = "top";
        }
        // window resize
        var resizeTimer;
        $(window).on("resize" + self.ns, function() {
            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }
            resizeTimer = setTimeout(function() {
                self.updateSliderSize();
            }, 50);
        });
        self.ev.trigger("rsAfterPropsSetup");
        // navigation (bullets, thumbs...) are created here
        self.updateSliderSize();
        // keyboard nav
        if (self.st.keyboardNavEnabled) {
            self._bindKeyboardNav();
        }
        if (self.st.arrowsNavHideOnTouch && (self.hasTouch || self.msTouch)) {
            self.st.arrowsNav = false;
        }
        //Direction navigation (arrows)
        if (self.st.arrowsNav) {
            var rArr = "rsArrow", container = self._controlsContainer;
            $('<div class="' + rArr + " " + rArr + 'Left"><div class="' + rArr + 'Icn"></div></div><div class="' + rArr + " " + rArr + 'Right"><div class="' + rArr + 'Icn"></div></div>').appendTo(container);
            self._arrowLeft = container.children("." + rArr + "Left").click(function(e) {
                e.preventDefault();
                self.prev();
            });
            self._arrowRight = container.children("." + rArr + "Right").click(function(e) {
                e.preventDefault();
                self.next();
            });
            if (self.st.arrowsNavAutoHide && !self.hasTouch) {
                self._arrowLeft.addClass("rsHidden");
                self._arrowRight.addClass("rsHidden");
                var hoverEl = container;
                hoverEl.one("mousemove.arrowshover", function() {
                    self._arrowLeft.removeClass("rsHidden");
                    self._arrowRight.removeClass("rsHidden");
                });
                hoverEl.hover(function() {
                    if (!self._arrowsAutoHideLocked) {
                        self._arrowLeft.removeClass("rsHidden");
                        self._arrowRight.removeClass("rsHidden");
                    }
                }, function() {
                    if (!self._arrowsAutoHideLocked) {
                        self._arrowLeft.addClass("rsHidden");
                        self._arrowRight.addClass("rsHidden");
                    }
                });
            }
            self.ev.on("rsOnUpdateNav", function() {
                self._updateArrowsNav();
            });
            self._updateArrowsNav();
        }
        if (self._hasDrag) {
            self._slidesContainer.on(self._downEvent, function(e) {
                self._onDragStart(e);
            });
        } else {
            self.dragSuccess = false;
        }
        var videoClasses = [ "rsPlayBtnIcon", "rsPlayBtn", "rsCloseVideoBtn", "rsCloseVideoIcn" ];
        self._slidesContainer.click(function(e) {
            if (!self.dragSuccess) {
                var t = $(e.target);
                var tClass = t.attr("class");
                if ($.inArray(tClass, videoClasses) !== -1) {
                    if (self.toggleVideo()) {
                        return false;
                    }
                }
                if (self.st.navigateByClick && !self._blockActions) {
                    if ($(e.target).closest(".rsNoDrag", self._currHolder).length) {
                        return true;
                    }
                    self._mouseNext(e);
                }
                self.ev.trigger("rsSlideClick");
            }
        }).on("click.rs", "a", function(e) {
            if (self.dragSuccess) {
                return false;
            } else {
                self._blockActions = true;
                //e.stopPropagation();
                //e.stopImmediatePropagation();
                setTimeout(function() {
                    self._blockActions = false;
                }, 3);
            }
        });
        self.ev.trigger("rsAfterInit");
    }
    /* RoyalSlider Constructor End */
    /**
	 *
	 * RoyalSlider Core Prototype
	 * 
	 */
    RoyalSlider.prototype = {
        constructor: RoyalSlider,
        _mouseNext: function(e) {
            var self = this, relativePos = e[self._slidesHorizontal ? "pageX" : "pageY"] - self._sliderOffset;
            if (relativePos >= self._nextSlidePos) {
                self.next();
            } else if (relativePos < 0) {
                self.prev();
            }
        },
        _refreshNumPreloadImages: function() {
            var self = this, n;
            n = self.st.numImagesToPreload;
            self._loop = self.st.loop;
            if (self._loop) {
                if (self.numSlides === 2) {
                    self._loop = false;
                    self.st.loopRewind = true;
                } else if (self.numSlides < 2) {
                    self.st.loopRewind = self._loop = false;
                }
            }
            if (self._loop && n > 0) {
                if (self.numSlides <= 4) {
                    n = 1;
                } else {
                    if (self.st.numImagesToPreload > (self.numSlides - 1) / 2) {
                        n = Math.floor((self.numSlides - 1) / 2);
                    }
                }
            }
            self._numPreloadImages = n;
        },
        _parseNode: function(content, pushToSlides) {
            var self = this, hasImg, isRoot, hasCover, obj = {}, tempEl, first = true;
            content = $(content);
            self._currContent = content;
            self.ev.trigger("rsBeforeParseNode", [ content, obj ]);
            if (obj.stopParsing) {
                return;
            }
            content = self._currContent;
            obj.id = self._idCount;
            obj.contentAdded = false;
            self._idCount++;
            obj.images = [];
            obj.isBig = false;
            if (!obj.hasCover) {
                if (content.hasClass("rsImg")) {
                    tempEl = content;
                    hasImg = true;
                } else {
                    tempEl = content.find(".rsImg");
                    if (tempEl.length) {
                        hasImg = true;
                    }
                }
                if (hasImg) {
                    obj.bigImage = tempEl.eq(0).attr("data-rsBigImg");
                    tempEl.each(function() {
                        var item = $(this);
                        if (item.is("a")) {
                            parseEl(item, "href");
                        } else if (item.is("img")) {
                            parseEl(item, "src");
                        } else {
                            parseEl(item);
                        }
                    });
                } else if (content.is("img")) {
                    content.addClass("rsImg rsMainSlideImage");
                    parseEl(content, "src");
                }
            }
            tempEl = content.find(".rsCaption");
            if (tempEl.length) {
                obj.caption = tempEl.remove();
            }
            obj.content = content;
            self.ev.trigger("rsAfterParseNode", [ content, obj ]);
            function parseEl(el, s) {
                if (s) {
                    obj.images.push(el.attr(s));
                } else {
                    obj.images.push(el.text());
                }
                if (first) {
                    first = false;
                    obj.caption = s === "src" ? el.attr("alt") : el.contents();
                    obj.image = obj.images[0];
                    obj.videoURL = el.attr("data-rsVideo");
                    var wAtt = el.attr("data-rsw"), hAtt = el.attr("data-rsh");
                    if (typeof wAtt !== "undefined" && wAtt !== false && typeof hAtt !== "undefined" && hAtt !== false) {
                        obj.iW = parseInt(wAtt);
                        obj.iH = parseInt(hAtt);
                    } else if (self.st.imgWidth && self.st.imgHeight) {
                        obj.iW = self.st.imgWidth;
                        obj.iH = self.st.imgHeight;
                    }
                }
            }
            if (pushToSlides) {
                self.slides.push(obj);
            }
            if (obj.images.length === 0) {
                obj.isLoaded = true;
                obj.isRendered = false;
                obj.isLoading = false;
                obj.images = null;
            }
            return obj;
        },
        _bindKeyboardNav: function() {
            var self = this, interval, keyCode, onKeyboardAction = function(keyCode) {
                if (keyCode === 37) {
                    self.prev();
                } else if (keyCode === 39) {
                    self.next();
                }
            };
            self._doc.on("keydown" + self.ns, function(e) {
                if (!self._isDragging) {
                    keyCode = e.keyCode;
                    if (keyCode === 37 || keyCode === 39) {
                        if (!interval) {
                            onKeyboardAction(keyCode);
                            interval = setInterval(function() {
                                onKeyboardAction(keyCode);
                            }, 700);
                        }
                    }
                }
            }).on("keyup" + self.ns, function(e) {
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
            });
        },
        goTo: function(id, notUserAction) {
            var self = this;
            if (id !== self.currSlideId) {
                self._moveTo(id, self.st.transitionSpeed, true, !notUserAction);
            }
        },
        destroy: function(remove) {
            var self = this;
            self.ev.trigger("rsBeforeDestroy");
            self._doc.off("keydown" + self.ns + " keyup" + self.ns + " " + self._moveEvent + " " + self._upEvent);
            self._slidesContainer.off(self._downEvent + " click");
            self.slider.data("royalSlider", null);
            $.removeData(self.slider, "royalSlider");
            $(window).off("resize" + self.ns);
            if (remove) {
                self.slider.remove();
            }
            self.slides = null;
            self.slider = null;
            self.ev = null;
        },
        _updateBlocksContent: function(beforeTransition, getId) {
            var self = this, item, i, n, pref, group, groupId, slideCode, loop = self._loop, numSlides = self.numSlides;
            if (!isNaN(getId)) {
                return getCorrectLoopedId(getId);
            }
            var id = self.currSlideId;
            var groupOffset;
            var itemsOnSide = beforeTransition ? Math.abs(self._prevSlideId - self.currSlideId) >= self.numSlides - 1 ? 0 : 1 : self._numPreloadImages;
            var itemsToCheck = Math.min(2, itemsOnSide);
            var updateAfter = false;
            var updateBefore = false;
            var tempId;
            for (i = id; i < id + 1 + itemsToCheck; i++) {
                tempId = getCorrectLoopedId(i);
                item = self.slides[tempId];
                if (item && (!item.isAdded || !item.positionSet)) {
                    updateAfter = true;
                    break;
                }
            }
            for (i = id - 1; i > id - 1 - itemsToCheck; i--) {
                tempId = getCorrectLoopedId(i);
                item = self.slides[tempId];
                if (item && (!item.isAdded || !item.positionSet)) {
                    updateBefore = true;
                    break;
                }
            }
            if (updateAfter) {
                for (i = id; i < id + itemsOnSide + 1; i++) {
                    tempId = getCorrectLoopedId(i);
                    groupOffset = Math.floor((self._realId - (id - i)) / self.numSlides) * self.numSlides;
                    item = self.slides[tempId];
                    if (item) {
                        updateItem(item, tempId);
                    }
                }
            }
            if (updateBefore) {
                for (i = id - 1; i > id - 1 - itemsOnSide; i--) {
                    tempId = getCorrectLoopedId(i);
                    groupOffset = Math.floor((self._realId - (id - i)) / numSlides) * numSlides;
                    item = self.slides[tempId];
                    if (item) {
                        updateItem(item, tempId);
                    }
                }
            }
            if (!beforeTransition) {
                var start = id;
                var distance = itemsOnSide;
                var min = getCorrectLoopedId(id - itemsOnSide);
                var max = getCorrectLoopedId(id + itemsOnSide);
                var nmin = min > max ? 0 : min;
                for (i = 0; i < numSlides; i++) {
                    if (min > max) {
                        if (i > min - 1) {
                            continue;
                        }
                    }
                    if (i < nmin || i > max) {
                        item = self.slides[i];
                        if (item && item.holder) {
                            //slideCode = self.slidesJQ[i];
                            //if(typeof slideCode !== "string") { 
                            item.holder.detach();
                            item.isAdded = false;
                        }
                    }
                }
            }
            function updateItem(item, i, slideCode) {
                if (!item.isAdded) {
                    if (!slideCode) slideCode = self.slidesJQ[i];
                    if (!item.holder) {
                        slideCode = self.slidesJQ[i] = $(slideCode);
                        item.holder = slideCode;
                    } else {
                        slideCode = item.holder;
                    }
                    item.appendOnLoaded = false;
                    updatePos(i, item, slideCode);
                    addContent(i, item);
                    self._addBlockToContainer(item, slideCode, beforeTransition);
                    item.isAdded = true;
                    appended = true;
                } else {
                    addContent(i, item);
                    updatePos(i, item);
                }
            }
            function addContent(i, item) {
                if (!item.contentAdded) {
                    self.setItemHtml(item, beforeTransition);
                    if (!beforeTransition) {
                        item.contentAdded = true;
                    }
                }
            }
            function updatePos(i, item, slideCode) {
                if (self._isMove) {
                    if (!slideCode) {
                        slideCode = self.slidesJQ[i];
                    }
                    slideCode.css(self._reorderProp, (i + self._idOffset + groupOffset) * self._slideSize);
                }
            }
            function getCorrectLoopedId(index) {
                var changed = false;
                if (loop) {
                    if (index > numSlides - 1) {
                        return getCorrectLoopedId(index - numSlides);
                    } else if (index < 0) {
                        return getCorrectLoopedId(numSlides + index);
                    }
                }
                return index;
            }
        },
        /**
		 * Sets or loads HTML for specified slide
		 * @param {Object} currSlideObject  holds data about curr slide (read about rsAfterParseNode for more info)
		 * @param {Boolean} beforeTransition determines if setItemHTML method is called before or after transition
		 */
        setItemHtml: function(currSlideObject, beforeTransition) {
            var self = this;
            if (currSlideObject.isLoaded) {
                appendContent();
                return;
            } else {
                if (beforeTransition) {
                    waitForTransition();
                } else {
                    parseDataAndLoad();
                }
            }
            function parseDataAndLoad() {
                if (!currSlideObject.images) {
                    currSlideObject.isRendered = true;
                    currSlideObject.isLoaded = true;
                    currSlideObject.isLoading = false;
                    appendContent(true);
                    return;
                }
                if (currSlideObject.isLoading) {
                    return;
                }
                var el, isRoot;
                if (currSlideObject.content.hasClass("rsImg")) {
                    el = currSlideObject.content;
                    isRoot = true;
                } else {
                    el = currSlideObject.content.find(".rsImg:not(img)");
                }
                if (el && !el.is("img")) {
                    el.each(function() {
                        var item = $(this), newEl = '<img class="rsImg" src="' + (item.is("a") ? item.attr("href") : item.text()) + '" />';
                        if (!isRoot) {
                            item.replaceWith(newEl);
                        } else {
                            currSlideObject.content = $(newEl);
                        }
                    });
                }
                el = isRoot ? currSlideObject.content : currSlideObject.content.find("img.rsImg");
                setPreloader();
                el.eq(0).addClass("rsMainSlideImage");
                if (currSlideObject.iW && currSlideObject.iH) {
                    if (!currSlideObject.isLoaded) {
                        self._resizeImage(currSlideObject);
                    }
                    appendContent();
                }
                currSlideObject.isLoading = true;
                var newEl;
                if (currSlideObject.isBig) {
                    $("<img />").on("load.rs error.rs", function(e) {
                        onLoad([ this ], true);
                    }).attr("src", currSlideObject.image);
                } else {
                    currSlideObject.loaded = [];
                    currSlideObject.imgLoaders = [];
                    for (var i = 0; i < currSlideObject.images.length; i++) {
                        var image = $("<img />");
                        currSlideObject.imgLoaders.push(this);
                        image.on("load.rs error.rs", function(e) {
                            currSlideObject.loaded.push(this);
                            if (currSlideObject.loaded.length === currSlideObject.imgLoaders.length) {
                                onLoad(currSlideObject.loaded, false);
                            }
                        }).attr("src", currSlideObject.images[i]);
                    }
                }
            }
            function onLoad($images, isBig) {
                if ($images.length) {
                    var img = $images[0], src = img.src;
                    if (isBig !== currSlideObject.isBig) {
                        var c = currSlideObject.holder.children();
                        if (c && c.length > 1) {
                            removePreloader();
                        }
                        return;
                    }
                    if (currSlideObject.iW && currSlideObject.iH) {
                        imageLoadingComplete();
                        return;
                    }
                    currSlideObject.iW = img.width;
                    currSlideObject.iH = img.height;
                    if (currSlideObject.iW && currSlideObject.iH) {
                        imageLoadingComplete();
                        return;
                    } else {
                        // if no size, try again
                        var loader = new Image();
                        loader.onload = function() {
                            if (loader.width) {
                                currSlideObject.iW = loader.width;
                                currSlideObject.iH = loader.height;
                                imageLoadingComplete();
                            } else {
                                setTimeout(function() {
                                    if (loader.width) {
                                        currSlideObject.iW = loader.width;
                                        currSlideObject.iH = loader.height;
                                    }
                                    // failed to get size on last tier, just output image
                                    imageLoadingComplete();
                                }, 1e3);
                            }
                        };
                        loader.src = img.src;
                    }
                } else {
                    imageLoadingComplete();
                }
            }
            function imageLoadingComplete() {
                currSlideObject.isLoaded = true;
                currSlideObject.isLoading = false;
                appendContent();
                removePreloader();
                triggerLoaded();
            }
            function waitForTransition() {
                if (!self._isMove && currSlideObject.images && currSlideObject.iW && currSlideObject.iH) {
                    parseDataAndLoad();
                    return;
                }
                currSlideObject.holder.isWaiting = true;
                setPreloader();
                currSlideObject.holder.slideId = -99;
            }
            function appendContent() {
                if (!currSlideObject.isAppended) {
                    var visibleNearby = self.st.visibleNearby, bId = currSlideObject.id - self._newSlideId;
                    if (!beforeTransition && !currSlideObject.appendOnLoaded && self.st.fadeinLoadedSlide && (bId === 0 || (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1))) {
                        var css = {
                            visibility: "visible",
                            opacity: 0
                        };
                        css[self._vendorPref + "transition"] = "opacity 400ms ease-in-out";
                        currSlideObject.content.css(css);
                        setTimeout(function() {
                            currSlideObject.content.css("opacity", 1);
                        }, 16);
                    }
                    if (currSlideObject.holder.find(".rsPreloader").length) {
                        currSlideObject.holder.append(currSlideObject.content);
                    } else {
                        currSlideObject.holder.html(currSlideObject.content);
                    }
                    currSlideObject.isAppended = true;
                    if (currSlideObject.isLoaded) {
                        self._resizeImage(currSlideObject);
                        triggerLoaded();
                    }
                    if (!currSlideObject.sizeReady) {
                        currSlideObject.sizeReady = true;
                        setTimeout(function() {
                            // triggers after content is added, usually is true when page is refreshed from cache
                            self.ev.trigger("rsMaybeSizeReady", currSlideObject);
                        }, 100);
                    }
                }
            }
            function triggerLoaded() {
                if (!currSlideObject.loadedTriggered) {
                    currSlideObject.isLoaded = currSlideObject.loadedTriggered = true;
                    currSlideObject.holder.trigger("rsAfterContentSet");
                    self.ev.trigger("rsAfterContentSet", currSlideObject);
                }
            }
            function setPreloader() {
                if (self.st.usePreloader) currSlideObject.holder.html(self._preloader.clone());
            }
            function removePreloader(now) {
                if (self.st.usePreloader) {
                    var preloader = currSlideObject.holder.find(".rsPreloader");
                    if (preloader.length) {
                        preloader.remove();
                    }
                }
            }
        },
        _addBlockToContainer: function(slideObject, content, dontFade) {
            var self = this;
            var holder = slideObject.holder;
            var bId = slideObject.id - self._newSlideId;
            var visibleNearby = false;
            // if(self._isMove && !dontFade && self.st.fadeinLoadedSlide  && ( bId === 0 || ( (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1) ) ) ) {
            // 	var content = slideObject.content;
            // 	content.css(self._vendorPref + 'transition', 'opacity 400ms ease-in-out').css({visibility: 'visible', opacity: 0});
            // 	//holder.css('opacity', 0);
            // 	self._slidesContainer.append(holder);
            // 	setTimeout(function() {
            // 		content.css('opacity', 1);
            // 		//self.ev.trigger('rsAfterContentSet', holder);
            // 	}, 6);
            // } else {
            self._slidesContainer.append(holder);
            //}
            slideObject.appendOnLoaded = false;
        },
        _onDragStart: function(e, isThumbs) {
            var self = this, point, wasAnimating, isTouch = e.type === "touchstart";
            self._isTouchGesture = isTouch;
            self.ev.trigger("rsDragStart");
            if ($(e.target).closest(".rsNoDrag", self._currHolder).length) {
                self.dragSuccess = false;
                return true;
            }
            if (!isThumbs) {
                if (self._isAnimating) {
                    self._wasAnimating = true;
                    self._stopAnimation();
                }
            }
            self.dragSuccess = false;
            if (self._isDragging) {
                if (isTouch) {
                    self._multipleTouches = true;
                }
                return;
            } else {
                if (isTouch) {
                    self._multipleTouches = false;
                }
            }
            self._setGrabbingCursor();
            if (isTouch) {
                //parsing touch event
                var touches = e.originalEvent.touches;
                if (touches && touches.length > 0) {
                    point = touches[0];
                    if (touches.length > 1) {
                        self._multipleTouches = true;
                    }
                } else {
                    return;
                }
            } else {
                e.preventDefault();
                point = e;
                if (self.msEnabled) point = point.originalEvent;
            }
            self._isDragging = true;
            self._doc.on(self._moveEvent, function(e) {
                self._onDragMove(e, isThumbs);
            }).on(self._upEvent, function(e) {
                self._onDragRelease(e, isThumbs);
            });
            self._currMoveAxis = "";
            self._hasMoved = false;
            self._pageX = point.pageX;
            self._pageY = point.pageY;
            self._startPagePos = self._accelerationPos = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal) ? point.pageX : point.pageY;
            self._horDir = 0;
            self._verDir = 0;
            self._currRenderPosition = !isThumbs ? self._sPosition : self._thumbsPosition;
            self._startTime = new Date().getTime();
            if (isTouch) {
                self._sliderOverflow.on(self._cancelEvent, function(e) {
                    self._onDragRelease(e, isThumbs);
                });
            }
        },
        _renderMovement: function(point, isThumbs) {
            var self = this;
            if (self._checkedAxis) {
                var timeStamp = self._renderMoveTime, deltaX = point.pageX - self._pageX, deltaY = point.pageY - self._pageY, newX = self._currRenderPosition + deltaX, newY = self._currRenderPosition + deltaY, isHorizontal = !isThumbs ? self._slidesHorizontal : self._thumbsHorizontal, newPos = isHorizontal ? newX : newY, mAxis = self._currMoveAxis;
                self._hasMoved = true;
                self._pageX = point.pageX;
                self._pageY = point.pageY;
                if (mAxis === "x" && deltaX !== 0) {
                    self._horDir = deltaX > 0 ? 1 : -1;
                } else if (mAxis === "y" && deltaY !== 0) {
                    self._verDir = deltaY > 0 ? 1 : -1;
                }
                var pointPos = isHorizontal ? self._pageX : self._pageY, deltaPos = isHorizontal ? deltaX : deltaY;
                if (!isThumbs) {
                    if (!self._loop) {
                        if (self.currSlideId <= 0) {
                            if (pointPos - self._startPagePos > 0) {
                                newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
                            }
                        }
                        if (self.currSlideId >= self.numSlides - 1) {
                            if (pointPos - self._startPagePos < 0) {
                                newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
                            }
                        }
                    }
                } else {
                    if (newPos > self._thumbsMinPosition) {
                        newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
                    } else if (newPos < self._thumbsMaxPosition) {
                        newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
                    }
                }
                self._currRenderPosition = newPos;
                if (timeStamp - self._startTime > 200) {
                    self._startTime = timeStamp;
                    self._accelerationPos = pointPos;
                }
                if (!isThumbs) {
                    if (self._isMove) {
                        self._setPosition(self._currRenderPosition);
                    }
                } else {
                    self._setThumbsPosition(self._currRenderPosition);
                }
            }
        },
        _onDragMove: function(e, isThumbs) {
            var self = this, point, isTouch = e.type === "touchmove";
            if (self._isTouchGesture && !isTouch) {
                return;
            }
            if (isTouch) {
                if (self._lockAxis) {
                    return;
                }
                var touches = e.originalEvent.touches;
                if (touches) {
                    if (touches.length > 1) {
                        return;
                    } else {
                        point = touches[0];
                    }
                } else {
                    return;
                }
            } else {
                point = e;
                if (self.msEnabled) point = point.originalEvent;
            }
            if (!self._hasMoved) {
                if (self._useCSS3Transitions) {
                    (!isThumbs ? self._slidesContainer : self._thumbsContainer).css(self._vendorPref + self._TD, "0s");
                }
                (function animloop() {
                    if (self._isDragging) {
                        self._animFrame = requestAnimationFrame(animloop);
                        if (self._renderMoveEvent) self._renderMovement(self._renderMoveEvent, isThumbs);
                    }
                })();
            }
            if (!self._checkedAxis) {
                var dir = !isThumbs ? self._slidesHorizontal : self._thumbsHorizontal, diff = Math.abs(point.pageX - self._pageX) - Math.abs(point.pageY - self._pageY) - (dir ? -7 : 7);
                if (diff > 7) {
                    // hor movement
                    if (dir) {
                        e.preventDefault();
                        self._currMoveAxis = "x";
                    } else if (isTouch) {
                        self._completeGesture();
                        return;
                    }
                    self._checkedAxis = true;
                } else if (diff < -7) {
                    // ver movement
                    if (!dir) {
                        e.preventDefault();
                        self._currMoveAxis = "y";
                    } else if (isTouch) {
                        self._completeGesture();
                        return;
                    }
                    self._checkedAxis = true;
                }
                return;
            }
            e.preventDefault();
            self._renderMoveTime = new Date().getTime();
            self._renderMoveEvent = point;
        },
        _completeGesture: function() {
            var self = this;
            self._lockAxis = true;
            self._hasMoved = self._isDragging = false;
            self._onDragRelease();
        },
        _onDragRelease: function(e, isThumbs) {
            var self = this, totalMoveDist, accDist, duration, v0, newPos, newDist, newDuration, blockLink, isTouch = e.type === "touchend" || e.type === "touchcancel";
            if (self._isTouchGesture && !isTouch) {
                return;
            }
            self._isTouchGesture = false;
            self.ev.trigger("rsDragRelease");
            self._renderMoveEvent = null;
            self._isDragging = false;
            self._lockAxis = false;
            self._checkedAxis = false;
            self._renderMoveTime = 0;
            cancelAnimationFrame(self._animFrame);
            if (self._hasMoved) {
                if (!isThumbs) {
                    if (self._isMove) {
                        self._setPosition(self._currRenderPosition);
                    }
                } else {
                    self._setThumbsPosition(self._currRenderPosition);
                }
            }
            self._doc.off(self._moveEvent).off(self._upEvent);
            if (isTouch) {
                self._sliderOverflow.off(self._cancelEvent);
            }
            self._setGrabCursor();
            if (!self._hasMoved && !self._multipleTouches) {
                if (isThumbs && self._thumbsEnabled) {
                    var item = $(e.target).closest(".rsNavItem");
                    if (item.length) {
                        self.goTo(item.index());
                    }
                    return;
                }
            }
            var orient = !isThumbs ? self._slidesHorizontal : self._thumbsHorizontal;
            if (!self._hasMoved || self._currMoveAxis === "y" && orient || self._currMoveAxis === "x" && !orient) {
                if (!isThumbs && self._wasAnimating) {
                    self._wasAnimating = false;
                    if (!self.st.navigateByClick) {
                        self.dragSuccess = true;
                    } else {
                        self._mouseNext(self.msEnabled ? e.originalEvent : e);
                        self.dragSuccess = true;
                        return;
                    }
                } else {
                    self._wasAnimating = false;
                    self.dragSuccess = false;
                    return;
                }
            } else {
                self.dragSuccess = true;
            }
            self._wasAnimating = false;
            self._currMoveAxis = "";
            function getCorrectSpeed(newSpeed) {
                if (newSpeed < 100) {
                    return 100;
                } else if (newSpeed > 500) {
                    return 500;
                }
                return newSpeed;
            }
            function returnToCurrent(isSlow, v0) {
                if (self._isMove || isThumbs) {
                    newPos = (-self._realId - self._idOffset) * self._slideSize;
                    newDist = Math.abs(self._sPosition - newPos);
                    self._currAnimSpeed = newDist / v0;
                    if (isSlow) {
                        self._currAnimSpeed += 250;
                    }
                    self._currAnimSpeed = getCorrectSpeed(self._currAnimSpeed);
                    self._animateTo(newPos, false);
                }
            }
            var snapDist = self.st.minSlideOffset, point = isTouch ? e.originalEvent.changedTouches[0] : self.msEnabled ? e.originalEvent : e, pPos = orient ? point.pageX : point.pageY, sPos = self._startPagePos, axPos = self._accelerationPos, axCurrItem = self.currSlideId, axNumItems = self.numSlides, dir = orient ? self._horDir : self._verDir, loop = self._loop, changeHash = false, distOffset = 0;
            totalMoveDist = Math.abs(pPos - sPos);
            accDist = pPos - axPos;
            duration = new Date().getTime() - self._startTime;
            v0 = Math.abs(accDist) / duration;
            if (dir === 0 || axNumItems <= 1) {
                returnToCurrent(true, v0);
                return;
            }
            if (!loop && !isThumbs) {
                if (axCurrItem <= 0) {
                    if (dir > 0) {
                        returnToCurrent(true, v0);
                        return;
                    }
                } else if (axCurrItem >= axNumItems - 1) {
                    if (dir < 0) {
                        returnToCurrent(true, v0);
                        return;
                    }
                }
            }
            if (!isThumbs) {
                if (sPos + snapDist < pPos) {
                    if (dir < 0) {
                        returnToCurrent(false, v0);
                        return;
                    }
                    self._moveTo("prev", getCorrectSpeed(Math.abs(self._sPosition - (-self._realId - self._idOffset + 1) * self._slideSize) / v0), changeHash, true, true);
                } else if (sPos - snapDist > pPos) {
                    if (dir > 0) {
                        returnToCurrent(false, v0);
                        return;
                    }
                    self._moveTo("next", getCorrectSpeed(Math.abs(self._sPosition - (-self._realId - self._idOffset - 1) * self._slideSize) / v0), changeHash, true, true);
                } else {
                    returnToCurrent(false, v0);
                }
            } else {
                var newPos = self._thumbsPosition;
                var transitionSpeed;
                if (newPos > self._thumbsMinPosition) {
                    newPos = self._thumbsMinPosition;
                } else if (newPos < self._thumbsMaxPosition) {
                    newPos = self._thumbsMaxPosition;
                } else {
                    var friction = .003, S = v0 * v0 / (friction * 2), minXDist = -self._thumbsPosition, maxXDist = self._thumbsContainerSize - self._thumbsViewportSize + self._thumbsPosition;
                    if (accDist > 0 && S > minXDist) {
                        minXDist = minXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
                        v0 = v0 * minXDist / S;
                        S = minXDist;
                    } else if (accDist < 0 && S > maxXDist) {
                        maxXDist = maxXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
                        v0 = v0 * maxXDist / S;
                        S = maxXDist;
                    }
                    transitionSpeed = Math.max(Math.round(v0 / friction), 50);
                    newPos = newPos + S * (accDist < 0 ? -1 : 1);
                    if (newPos > self._thumbsMinPosition) {
                        self._animateThumbsTo(newPos, transitionSpeed, true, self._thumbsMinPosition, 200);
                        return;
                    } else if (newPos < self._thumbsMaxPosition) {
                        self._animateThumbsTo(newPos, transitionSpeed, true, self._thumbsMaxPosition, 200);
                        return;
                    }
                }
                self._animateThumbsTo(newPos, transitionSpeed, true);
            }
        },
        _setPosition: function(pos) {
            var self = this;
            pos = self._sPosition = pos;
            if (self._useCSS3Transitions) {
                self._slidesContainer.css(self._xProp, self._tPref1 + (self._slidesHorizontal ? pos + self._tPref2 + 0 : 0 + self._tPref2 + pos) + self._tPref3);
            } else {
                self._slidesContainer.css(self._slidesHorizontal ? self._xProp : self._yProp, pos);
            }
        },
        updateSliderSize: function(force) {
            var self = this, newWidth, newHeight;
            if (self.st.autoScaleSlider) {
                var asw = self.st.autoScaleSliderWidth, ash = self.st.autoScaleSliderHeight;
                if (self.st.autoScaleHeight) {
                    newWidth = self.slider.width();
                    if (newWidth != self.width) {
                        self.slider.css("height", newWidth * (ash / asw));
                        newWidth = self.slider.width();
                    }
                    newHeight = self.slider.height();
                } else {
                    newHeight = self.slider.height();
                    if (newHeight != self.height) {
                        self.slider.css("width", newHeight * (asw / ash));
                        newHeight = self.slider.height();
                    }
                    newWidth = self.slider.width();
                }
            } else {
                newWidth = self.slider.width();
                newHeight = self.slider.height();
            }
            if (force || newWidth != self.width || newHeight != self.height) {
                self.width = newWidth;
                self.height = newHeight;
                self._wrapWidth = newWidth;
                self._wrapHeight = newHeight;
                self.ev.trigger("rsBeforeSizeSet");
                self.ev.trigger("rsAfterSizePropSet");
                self._sliderOverflow.css({
                    width: self._wrapWidth,
                    height: self._wrapHeight
                });
                self._slideSize = (self._slidesHorizontal ? self._wrapWidth : self._wrapHeight) + self.st.slidesSpacing;
                self._imagePadding = self.st.imageScalePadding;
                var item, slideItem, i, img;
                for (i = 0; i < self.slides.length; i++) {
                    item = self.slides[i];
                    item.positionSet = false;
                    if (item && item.images && item.isLoaded) {
                        item.isRendered = false;
                        self._resizeImage(item);
                    }
                }
                if (self._cloneHolders) {
                    for (i = 0; i < self._cloneHolders.length; i++) {
                        item = self._cloneHolders[i];
                        item.holder.css(self._reorderProp, (item.id + self._idOffset) * self._slideSize);
                    }
                }
                self._updateBlocksContent();
                if (self._isMove) {
                    if (self._useCSS3Transitions) {
                        self._slidesContainer.css(self._vendorPref + "transition-duration", "0s");
                    }
                    self._setPosition((-self._realId - self._idOffset) * self._slideSize);
                }
                self.ev.trigger("rsOnUpdateNav");
            }
            self._sliderOffset = self._sliderOverflow.offset();
            self._sliderOffset = self._sliderOffset[self._reorderProp];
        },
        //setSlidesOrientation: function(orient) {
        // TODO
        // var self = this,
        // 	newHor = Boolean(orient === 'horizontal');
        // if(self._slidesHorizontal !== newHor) {
        // 	self._setPosition(0);
        // 	if(self._isMove) {
        // 		for(var i = 0; i < self._slideHolders.length; i++) {
        // 			self._slideHolders[i].block.css(self._reorderProp, '');
        // 		}
        // 	}
        // 	self.slider.removeClass(self._slidesHorizontal ? 'rsHor' : 'rsVer').addClass(newHor ? 'rsHor' : 'rsVer');
        // 	self._slidesHorizontal = newHor;
        // 	self._reorderProp = newHor ? 'left' : 'top';
        // 	self.updateSliderSize(true);
        // }
        //},
        /**
		 * Adds slide
		 * @param  {jQuery object or raw HTML} htmltext 
		 * @param  {int} index    (optional) Index where item should be added (last item is removed of not specified)
		 */
        appendSlide: function(htmltext, index) {
            var self = this, parsedSlide = self._parseNode(htmltext);
            if (isNaN(index) || index > self.numSlides) {
                index = self.numSlides;
            }
            self.slides.splice(index, 0, parsedSlide);
            self.slidesJQ.splice(index, 0, '<div style="' + (self._isMove ? "position:absolute;" : self._opacityCSS) + '" class="rsSlide"></div>');
            if (index < self.currSlideId) {
                self.currSlideId++;
            }
            self.ev.trigger("rsOnAppendSlide", [ parsedSlide, index ]);
            self._refreshSlides(index);
            if (index === self.currSlideId) {
                self.ev.trigger("rsAfterSlideChange");
            }
        },
        /**
		 * Removes slide
		 * @param  {int} Index of item that should be removed
		 */
        removeSlide: function(index) {
            var self = this, slideToRemove = self.slides[index];
            if (slideToRemove) {
                if (slideToRemove.holder) {
                    slideToRemove.holder.remove();
                }
                if (index < self.currSlideId) {
                    self.currSlideId--;
                }
                self.slides.splice(index, 1);
                self.slidesJQ.splice(index, 1);
                self.ev.trigger("rsOnRemoveSlide", [ index ]);
                self._refreshSlides(index);
                if (index === self.currSlideId) {
                    self.ev.trigger("rsAfterSlideChange");
                }
            }
        },
        _refreshSlides: function(refreshIndex) {
            // todo: optimize this stuff
            var self = this;
            var oldNumSlides = self.numSlides;
            var numLoops = self._realId <= 0 ? 0 : Math.floor(self._realId / oldNumSlides);
            self.numSlides = self.slides.length;
            if (self.numSlides === 0) {
                self.currSlideId = self._idOffset = self._realId = 0;
                self.currSlide = self._oldHolder = null;
            } else {
                self._realId = numLoops * self.numSlides + self.currSlideId;
            }
            for (var i = 0; i < self.numSlides; i++) {
                self.slides[i].id = i;
            }
            self.currSlide = self.slides[self.currSlideId];
            self._currHolder = self.slidesJQ[self.currSlideId];
            if (self.currSlideId >= self.numSlides) {
                self.goTo(self.numSlides - 1);
            } else if (self.currSlideId < 0) {
                self.goTo(0);
            }
            self._refreshNumPreloadImages();
            if (self._isMove && self._loop) {
                self._slidesContainer.css(self._vendorPref + self._TD, "0ms");
            }
            if (self._refreshSlidesTimeout) {
                clearTimeout(self._refreshSlidesTimeout);
            }
            self._refreshSlidesTimeout = setTimeout(function() {
                if (self._isMove) {
                    self._setPosition((-self._realId - self._idOffset) * self._slideSize);
                }
                self._updateBlocksContent();
                if (!self._isMove) {
                    self._currHolder.css({
                        display: "block",
                        opacity: 1
                    });
                }
            }, 14);
            self.ev.trigger("rsOnUpdateNav");
        },
        _setGrabCursor: function() {
            var self = this;
            if (self._hasDrag && self._isMove) {
                if (self._grabCursor) {
                    self._sliderOverflow.css("cursor", self._grabCursor);
                } else {
                    self._sliderOverflow.removeClass("grabbing-cursor");
                    self._sliderOverflow.addClass("grab-cursor");
                }
            }
        },
        _setGrabbingCursor: function() {
            var self = this;
            if (self._hasDrag && self._isMove) {
                if (self._grabbingCursor) {
                    self._sliderOverflow.css("cursor", self._grabbingCursor);
                } else {
                    self._sliderOverflow.removeClass("grab-cursor");
                    self._sliderOverflow.addClass("grabbing-cursor");
                }
            }
        },
        next: function(notUserAction) {
            var self = this;
            self._moveTo("next", self.st.transitionSpeed, true, !notUserAction);
        },
        prev: function(notUserAction) {
            var self = this;
            self._moveTo("prev", self.st.transitionSpeed, true, !notUserAction);
        },
        _moveTo: function(type, speed, inOutEasing, userAction, fromSwipe) {
            var self = this, newPos, difference, i;
            self.ev.trigger("rsBeforeMove", [ type, userAction ]);
            if (type === "next") {
                newItemId = self.currSlideId + 1;
            } else if (type === "prev") {
                newItemId = self.currSlideId - 1;
            } else {
                newItemId = type = parseInt(type, 10);
            }
            if (!self._loop) {
                if (newItemId < 0) {
                    self._doBackAndForthAnim("left", !userAction);
                    return;
                } else if (newItemId >= self.numSlides) {
                    self._doBackAndForthAnim("right", !userAction);
                    return;
                }
            }
            if (self._isAnimating) {
                self._stopAnimation(true);
                inOutEasing = false;
            }
            difference = newItemId - self.currSlideId;
            self._prevSlideId = self.currSlideId;
            var prevId = self.currSlideId;
            var id = self.currSlideId + difference;
            var realId = self._realId;
            var temp;
            var delayed;
            if (self._loop) {
                id = self._updateBlocksContent(false, id);
                realId += difference;
            } else {
                realId = id;
            }
            self._newSlideId = id;
            self._oldHolder = self.slidesJQ[self.currSlideId];
            self._realId = realId;
            self.currSlideId = self._newSlideId;
            self.currSlide = self.slides[self.currSlideId];
            self._currHolder = self.slidesJQ[self.currSlideId];
            var checkDist = self.st.slidesDiff;
            var next = Boolean(difference > 0);
            var absDiff = Math.abs(difference);
            var g1 = Math.floor(prevId / self._numPreloadImages);
            var g2 = Math.floor((prevId + (next ? checkDist : -checkDist)) / self._numPreloadImages);
            var biggest = next ? Math.max(g1, g2) : Math.min(g1, g2);
            var biggestId = biggest * self._numPreloadImages + (next ? self._numPreloadImages - 1 : 0);
            if (biggestId > self.numSlides - 1) {
                biggestId = self.numSlides - 1;
            } else if (biggestId < 0) {
                biggestId = 0;
            }
            var toLast = next ? biggestId - prevId : prevId - biggestId;
            if (toLast > self._numPreloadImages) {
                toLast = self._numPreloadImages;
            }
            if (absDiff > toLast + checkDist) {
                self._idOffset += (absDiff - (toLast + checkDist)) * (next ? -1 : 1);
                speed = speed * 1.4;
                for (i = 0; i < self.numSlides; i++) {
                    self.slides[i].positionSet = false;
                }
            }
            self._currAnimSpeed = speed;
            self._updateBlocksContent(true);
            if (!fromSwipe) {
                delayed = true;
            }
            newPos = (-realId - self._idOffset) * self._slideSize;
            if (delayed) {
                setTimeout(function() {
                    self._isWorking = false;
                    self._animateTo(newPos, type, false, inOutEasing);
                    self.ev.trigger("rsOnUpdateNav");
                }, 0);
            } else {
                self._animateTo(newPos, type, false, inOutEasing);
                self.ev.trigger("rsOnUpdateNav");
            }
            function isSetToCurrent(testId) {
                if (testId < 0) {
                    testId = self.numSlides + testId;
                } else if (testId > self.numSlides - 1) {
                    testId = testId - self.numSlides;
                }
                if (testId !== self.currSlideId) {
                    return false;
                }
                return true;
            }
        },
        _updateArrowsNav: function() {
            var self = this, arrDisClass = "rsArrowDisabled";
            if (self.st.arrowsNav) {
                if (self.numSlides <= 1) {
                    self._arrowLeft.css("display", "none");
                    self._arrowRight.css("display", "none");
                    return;
                } else {
                    self._arrowLeft.css("display", "block");
                    self._arrowRight.css("display", "block");
                }
                if (!self._loop && !self.st.loopRewind) {
                    if (self.currSlideId === 0) {
                        self._arrowLeft.addClass(arrDisClass);
                    } else {
                        self._arrowLeft.removeClass(arrDisClass);
                    }
                    if (self.currSlideId === self.numSlides - 1) {
                        self._arrowRight.addClass(arrDisClass);
                    } else {
                        self._arrowRight.removeClass(arrDisClass);
                    }
                }
            }
        },
        _animateTo: function(pos, dir, loadAll, inOutEasing, customComplete) {
            var self = this, moveProp, oldBlock, animBlock;
            var animObj = {};
            if (isNaN(self._currAnimSpeed)) {
                self._currAnimSpeed = 400;
            }
            self._sPosition = self._currRenderPosition = pos;
            self.ev.trigger("rsBeforeAnimStart");
            if (!self._useCSS3Transitions) {
                if (self._isMove) {
                    animObj[self._slidesHorizontal ? self._xProp : self._yProp] = pos + "px";
                    self._slidesContainer.animate(animObj, self._currAnimSpeed, /*'easeOutQuart'*/ inOutEasing ? self.st.easeInOut : self.st.easeOut);
                } else {
                    oldBlock = self._oldHolder;
                    animBlock = self._currHolder;
                    animBlock.stop(true, true).css({
                        opacity: 0,
                        display: "block",
                        zIndex: self._fadeZIndex
                    });
                    self._currAnimSpeed = self.st.transitionSpeed;
                    animBlock.animate({
                        opacity: 1
                    }, self._currAnimSpeed, self.st.easeInOut);
                    clearTimeouts();
                    if (oldBlock) {
                        oldBlock.data("rsTimeout", setTimeout(function() {
                            oldBlock.stop(true, true).css({
                                opacity: 0,
                                display: "none",
                                zIndex: 0
                            });
                        }, self._currAnimSpeed + 60));
                    }
                }
            } else {
                if (self._isMove) {
                    self._currAnimSpeed = parseInt(self._currAnimSpeed);
                    var td = self._vendorPref + self._TD;
                    var ttf = self._vendorPref + self._TTF;
                    animObj[td] = self._currAnimSpeed + "ms";
                    animObj[ttf] = inOutEasing ? $.rsCSS3Easing[self.st.easeInOut] : $.rsCSS3Easing[self.st.easeOut];
                    self._slidesContainer.css(animObj);
                    if (inOutEasing || !self.hasTouch) {
                        setTimeout(function() {
                            self._setPosition(pos);
                        }, 5);
                    } else {
                        self._setPosition(pos);
                    }
                } else {
                    //self._currAnimSpeed = 10
                    self._currAnimSpeed = self.st.transitionSpeed;
                    oldBlock = self._oldHolder;
                    animBlock = self._currHolder;
                    if (animBlock.data("rsTimeout")) {
                        animBlock.css("opacity", 0);
                    }
                    clearTimeouts();
                    if (oldBlock) {
                        //if(oldBlock)
                        oldBlock.data("rsTimeout", setTimeout(function() {
                            animObj[self._vendorPref + self._TD] = "0ms";
                            animObj.zIndex = 0;
                            animObj.display = "none";
                            oldBlock.data("rsTimeout", "");
                            oldBlock.css(animObj);
                            setTimeout(function() {
                                oldBlock.css("opacity", 0);
                            }, 16);
                        }, self._currAnimSpeed + 60));
                    }
                    animObj.display = "block";
                    animObj.zIndex = self._fadeZIndex;
                    animObj.opacity = 0;
                    animObj[self._vendorPref + self._TD] = "0ms";
                    animObj[self._vendorPref + self._TTF] = $.rsCSS3Easing[self.st.easeInOut];
                    animBlock.css(animObj);
                    animBlock.data("rsTimeout", setTimeout(function() {
                        //animBlock.css('opacity', 0);
                        animBlock.css(self._vendorPref + self._TD, self._currAnimSpeed + "ms");
                        //oldBlock.css(self._vendorPref + self._TD,  '0ms');
                        animBlock.data("rsTimeout", setTimeout(function() {
                            animBlock.css("opacity", 1);
                            animBlock.data("rsTimeout", "");
                        }, 20));
                    }, 20));
                }
            }
            self._isAnimating = true;
            if (self.loadingTimeout) {
                clearTimeout(self.loadingTimeout);
            }
            if (customComplete) {
                self.loadingTimeout = setTimeout(function() {
                    self.loadingTimeout = null;
                    customComplete.call();
                }, self._currAnimSpeed + 60);
            } else {
                self.loadingTimeout = setTimeout(function() {
                    self.loadingTimeout = null;
                    self._animationComplete(dir);
                }, self._currAnimSpeed + 60);
            }
            function clearTimeouts() {
                var t;
                if (oldBlock) {
                    t = oldBlock.data("rsTimeout");
                    if (t) {
                        if (oldBlock !== animBlock) {
                            oldBlock.css({
                                opacity: 0,
                                display: "none",
                                zIndex: 0
                            });
                        }
                        clearTimeout(t);
                        oldBlock.data("rsTimeout", "");
                    }
                }
                t = animBlock.data("rsTimeout");
                if (t) {
                    clearTimeout(t);
                    animBlock.data("rsTimeout", "");
                }
            }
        },
        _stopAnimation: function(noCSS3) {
            var self = this;
            self._isAnimating = false;
            clearTimeout(self.loadingTimeout);
            if (self._isMove) {
                if (!self._useCSS3Transitions) {
                    self._slidesContainer.stop(true);
                    self._sPosition = parseInt(self._slidesContainer.css(self._xProp), 10);
                } else if (!noCSS3) {
                    var oldPos = self._sPosition;
                    var newPos = self._currRenderPosition = self._getTransformProp();
                    self._slidesContainer.css(self._vendorPref + self._TD, "0ms");
                    if (oldPos !== newPos) {
                        self._setPosition(newPos);
                    }
                }
            } else {
                // kung fu
                if (self._fadeZIndex > 20) {
                    self._fadeZIndex = 10;
                } else {
                    self._fadeZIndex++;
                }
            }
        },
        // Thanks to @benpbarnett
        _getTransformProp: function() {
            var self = this, transform = window.getComputedStyle(self._slidesContainer.get(0), null).getPropertyValue(self._vendorPref + "transform"), explodedMatrix = transform.replace(/^matrix\(/i, "").split(/, |\)$/g), isMatrix3d = explodedMatrix[0].indexOf("matrix3d") === 0;
            return parseInt(explodedMatrix[self._slidesHorizontal ? isMatrix3d ? 12 : 4 : isMatrix3d ? 13 : 5], 10);
        },
        _getCSS3Prop: function(pos, hor) {
            var self = this;
            return self._useCSS3Transitions ? self._tPref1 + (hor ? pos + self._tPref2 + 0 : 0 + self._tPref2 + pos) + self._tPref3 : pos;
        },
        _animationComplete: function(dir) {
            var self = this;
            if (!self._isMove) {
                self._currHolder.css("z-index", 0);
                self._fadeZIndex = 10;
            }
            self._isAnimating = false;
            self.staticSlideId = self.currSlideId;
            self._updateBlocksContent();
            self._slidesMoved = false;
            self.ev.trigger("rsAfterSlideChange");
        },
        _doBackAndForthAnim: function(type, userAction) {
            var self = this, newPos = (-self._realId - self._idOffset) * self._slideSize;
            if (self.numSlides === 0 || self._isAnimating) {
                return;
            }
            if (self.st.loopRewind) {
                self.goTo(type === "left" ? self.numSlides - 1 : 0, userAction);
                return;
            }
            if (self._isMove) {
                self._currAnimSpeed = 200;
                function allAnimComplete() {
                    self._isAnimating = false;
                }
                function firstAnimComplete() {
                    self._isAnimating = false;
                    self._animateTo(newPos, "", false, true, allAnimComplete);
                }
                self._animateTo(newPos + (type === "left" ? 30 : -30), "", false, true, firstAnimComplete);
            }
        },
        _resizeImage: function(slideObject, useClone) {
            var isRoot = true;
            if (slideObject.isRendered) {
                return;
            }
            var img = slideObject.content;
            var classToFind = "rsMainSlideImage";
            var isVideo;
            var self = this, imgAlignCenter = self.st.imageAlignCenter, imgScaleMode = self.st.imageScaleMode, tempEl;
            if (slideObject.videoURL) {
                classToFind = "rsVideoContainer";
                if (imgScaleMode !== "fill") {
                    isVideo = true;
                } else {
                    tempEl = img;
                    if (!tempEl.hasClass(classToFind)) {
                        tempEl = tempEl.find("." + classToFind);
                    }
                    tempEl.css({
                        width: "100%",
                        height: "100%"
                    });
                    classToFind = "rsMainSlideImage";
                }
            }
            if (!img.hasClass(classToFind)) {
                isRoot = false;
                img = img.find("." + classToFind);
            }
            if (!img) {
                return;
            }
            var baseImageWidth = slideObject.iW, baseImageHeight = slideObject.iH;
            slideObject.isRendered = true;
            if (imgScaleMode === "none" && !imgAlignCenter) {
                return;
            }
            if (imgScaleMode !== "fill") {
                bMargin = self._imagePadding;
            } else {
                bMargin = 0;
            }
            //var block = img.parent('.block-inside').css('margin', bMargin);
            var containerWidth = self._wrapWidth - bMargin * 2, containerHeight = self._wrapHeight - bMargin * 2, hRatio, vRatio, ratio, nWidth, nHeight, cssObj = {};
            if (imgScaleMode === "fit-if-smaller") {
                if (baseImageWidth > containerWidth || baseImageHeight > containerHeight) {
                    imgScaleMode = "fit";
                }
            }
            if (imgScaleMode === "fill" || imgScaleMode === "fit") {
                hRatio = containerWidth / baseImageWidth;
                vRatio = containerHeight / baseImageHeight;
                if (imgScaleMode == "fill") {
                    ratio = hRatio > vRatio ? hRatio : vRatio;
                } else if (imgScaleMode == "fit") {
                    ratio = hRatio < vRatio ? hRatio : vRatio;
                } else {
                    ratio = 1;
                }
                nWidth = Math.ceil(baseImageWidth * ratio, 10);
                nHeight = Math.ceil(baseImageHeight * ratio, 10);
            } else {
                nWidth = baseImageWidth;
                nHeight = baseImageHeight;
            }
            if (imgScaleMode !== "none") {
                cssObj.width = nWidth;
                cssObj.height = nHeight;
                if (isVideo) {
                    img.find(".rsImg").css({
                        width: "100%",
                        height: "100%"
                    });
                }
            }
            if (imgAlignCenter) {
                cssObj.marginLeft = Math.floor((containerWidth - nWidth) / 2) + bMargin;
                cssObj.marginTop = Math.floor((containerHeight - nHeight) / 2) + bMargin;
            }
            img.css(cssObj);
        }
    };
    /* RoyalSlider core prototype end */
    $.rsProto = RoyalSlider.prototype;
    $.fn.royalSlider = function(options) {
        var args = arguments;
        return this.each(function() {
            var self = $(this);
            if (typeof options === "object" || !options) {
                if (!self.data("royalSlider")) {
                    self.data("royalSlider", new RoyalSlider(self, options));
                }
            } else {
                var royalSlider = self.data("royalSlider");
                if (royalSlider && royalSlider[options]) {
                    return royalSlider[options].apply(royalSlider, Array.prototype.slice.call(args, 1));
                }
            }
        });
    };
    $.fn.royalSlider.defaults = {
        slidesSpacing: 8,
        startSlideId: 0,
        loop: false,
        loopRewind: false,
        numImagesToPreload: 4,
        fadeinLoadedSlide: true,
        slidesOrientation: "horizontal",
        transitionType: "move",
        transitionSpeed: 600,
        controlNavigation: "bullets",
        controlsInside: true,
        arrowsNav: true,
        arrowsNavAutoHide: true,
        navigateByClick: true,
        randomizeSlides: false,
        sliderDrag: true,
        sliderTouch: true,
        keyboardNavEnabled: false,
        fadeInAfterLoaded: true,
        allowCSS3: true,
        allowCSS3OnWebkit: true,
        addActiveClass: false,
        autoHeight: false,
        easeOut: "easeOutSine",
        easeInOut: "easeInOutSine",
        minSlideOffset: 10,
        imageScaleMode: "fit-if-smaller",
        imageAlignCenter: true,
        imageScalePadding: 4,
        usePreloader: true,
        autoScaleSlider: false,
        autoScaleSliderWidth: 800,
        autoScaleSliderHeight: 400,
        autoScaleHeight: true,
        arrowsNavHideOnTouch: false,
        globalCaption: false,
        slidesDiff: 2
    };
    /* default options end */
    $.rsCSS3Easing = {
        easeOutSine: "cubic-bezier(0.390, 0.575, 0.565, 1.000)",
        easeInOutSine: "cubic-bezier(0.445, 0.050, 0.550, 0.950)"
    };
    $.extend(jQuery.easing, {
        easeInOutSine: function(x, t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        },
        easeOutSine: function(x, t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        easeOutCubic: function(x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        }
    });
})(jQuery, window);

(function($) {
    /**
	 *
	 * RoyalSlider auto height module
	 * @version 1.0.2:
	 *
	 * 1.0.2
	 * - Changed "on" to "one" in afterInit event listener
	 * - Removed id="clear"
	 */
    $.extend($.rsProto, {
        _initAutoHeight: function() {
            var self = this;
            if (self.st.autoHeight) {
                var holder, tH, currSlide, currHeight, updHeight = function(animate) {
                    currSlide = self.slides[self.currSlideId];
                    holder = currSlide.holder;
                    if (holder) {
                        tH = holder.height();
                        if (tH && tH !== currHeight) {
                            self._wrapHeight = tH;
                            if (self._useCSS3Transitions || !animate) {
                                self._sliderOverflow.css("height", tH);
                            } else {
                                self._sliderOverflow.stop(true, true).animate({
                                    height: tH
                                }, self.st.transitionSpeed);
                            }
                        }
                    }
                };
                self.ev.on("rsMaybeSizeReady.rsAutoHeight", function(e, slideObject) {
                    if (currSlide === slideObject) {
                        updHeight();
                    }
                });
                self.ev.on("rsAfterContentSet.rsAutoHeight", function(e, slideObject) {
                    if (currSlide === slideObject) {
                        updHeight();
                    }
                });
                self.slider.addClass("rsAutoHeight");
                self.ev.one("rsAfterInit", function() {
                    setTimeout(function() {
                        updHeight(false);
                        setTimeout(function() {
                            self.slider.append('<div style="clear:both; float: none;"></div>');
                            if (self._useCSS3Transitions) {
                                self._sliderOverflow.css(self._vendorPref + "transition", "height " + self.st.transitionSpeed + "ms ease-in-out");
                            }
                        }, 16);
                    }, 16);
                });
                self.ev.on("rsBeforeAnimStart", function() {
                    updHeight(true);
                });
                self.ev.on("rsBeforeSizeSet", function() {
                    setTimeout(function() {
                        updHeight(false);
                    }, 16);
                });
            }
        }
    });
    $.rsModules.autoHeight = $.rsProto._initAutoHeight;
})(jQuery);

(function($) {
    /**
	 *
	 * RoyalSlider auto play module
	 * @version 1.0.5:
	 *
	 * 1.0.3:
	 * - added support for 'autoplay' property name. 
	 *
	 * 1.0.4
	 * - added toggleAutoPlay public method
	 *
	 * 1.0.5
	 * - Fixed issue when autoPlay may not pause when switching browser tabs
	 */
    $.extend($.rsProto, {
        _initAutoplay: function() {
            var self = this, del;
            self._autoPlayDefaults = {
                enabled: false,
                stopAtAction: true,
                pauseOnHover: true,
                delay: 2e3
            };
            // fix deprecated name
            if (!self.st.autoPlay && self.st.autoplay) {
                self.st.autoPlay = self.st.autoplay;
            }
            self.st.autoPlay = $.extend({}, self._autoPlayDefaults, self.st.autoPlay);
            if (self.st.autoPlay.enabled) {
                self.ev.on("rsBeforeParseNode", function(e, content, obj) {
                    content = $(content);
                    del = content.attr("data-rsDelay");
                    if (del) {
                        obj.customDelay = parseInt(del, 10);
                    }
                });
                self.ev.one("rsAfterInit", function() {
                    self._setupAutoPlay();
                });
                self.ev.on("rsBeforeDestroy", function() {
                    self.stopAutoPlay();
                    $(window).off("blur" + self.ns + " focus" + self.ns);
                });
            }
        },
        _setupAutoPlay: function() {
            var self = this;
            self.startAutoPlay();
            self.ev.on("rsAfterContentSet", function(e, slideObject) {
                if (!self._isDragging && !self._isAnimating && self._autoPlayEnabled && slideObject === self.currSlide) {
                    self._play();
                }
            });
            self.ev.on("rsDragRelease", function() {
                if (self._autoPlayEnabled && self._autoPlayPaused) {
                    self._autoPlayPaused = false;
                    self._play();
                }
            });
            self.ev.on("rsAfterSlideChange", function() {
                if (self._autoPlayEnabled) {
                    if (self._autoPlayPaused) {
                        self._autoPlayPaused = false;
                        if (self.currSlide.isLoaded) {
                            self._play();
                        }
                    }
                }
            });
            self.ev.on("rsDragStart", function() {
                if (self._autoPlayEnabled) {
                    if (self.st.autoPlay.stopAtAction) {
                        self.stopAutoPlay();
                    } else {
                        self._autoPlayPaused = true;
                        self._pause();
                    }
                }
            });
            self.ev.on("rsBeforeMove", function(e, type, userAction) {
                if (self._autoPlayEnabled) {
                    if (userAction && self.st.autoPlay.stopAtAction) {
                        self.stopAutoPlay();
                    } else {
                        self._autoPlayPaused = true;
                        self._pause();
                    }
                }
            });
            self._pausedByVideo = false;
            self.ev.on("rsVideoStop", function() {
                if (self._autoPlayEnabled) {
                    self._pausedByVideo = false;
                    self._play();
                }
            });
            self.ev.on("rsVideoPlay", function() {
                if (self._autoPlayEnabled) {
                    self._autoPlayPaused = false;
                    self._pause();
                    self._pausedByVideo = true;
                }
            });
            $(window).on("blur" + self.ns, function() {
                if (self._autoPlayEnabled) {
                    self._autoPlayPaused = true;
                    self._pause();
                }
            }).on("focus" + self.ns, function() {
                if (self._autoPlayEnabled && self._autoPlayPaused) {
                    self._autoPlayPaused = false;
                    self._play();
                }
            });
            if (self.st.autoPlay.pauseOnHover) {
                self._pausedByHover = false;
                self.slider.hover(function() {
                    if (self._autoPlayEnabled) {
                        self._autoPlayPaused = false;
                        self._pause();
                        self._pausedByHover = true;
                    }
                }, function() {
                    if (self._autoPlayEnabled) {
                        self._pausedByHover = false;
                        self._play();
                    }
                });
            }
        },
        toggleAutoPlay: function() {
            var self = this;
            if (self._autoPlayEnabled) {
                self.stopAutoPlay();
            } else {
                self.startAutoPlay();
            }
        },
        startAutoPlay: function() {
            var self = this;
            self._autoPlayEnabled = true;
            if (self.currSlide.isLoaded) {
                self._play();
            }
        },
        stopAutoPlay: function() {
            var self = this;
            self._pausedByVideo = self._pausedByHover = self._autoPlayPaused = self._autoPlayEnabled = false;
            self._pause();
        },
        _play: function() {
            var self = this;
            if (!self._pausedByHover && !self._pausedByVideo) {
                self._autoPlayRunning = true;
                if (self._autoPlayTimeout) {
                    clearTimeout(self._autoPlayTimeout);
                }
                self._autoPlayTimeout = setTimeout(function() {
                    var changed;
                    if (!self._loop && !self.st.loopRewind) {
                        changed = true;
                        self.st.loopRewind = true;
                    }
                    self.next(true);
                    if (changed) {
                        changed = false;
                        self.st.loopRewind = false;
                    }
                }, !self.currSlide.customDelay ? self.st.autoPlay.delay : self.currSlide.customDelay);
            }
        },
        _pause: function() {
            var self = this;
            if (!self._pausedByHover && !self._pausedByVideo) {
                self._autoPlayRunning = false;
                if (self._autoPlayTimeout) {
                    clearTimeout(self._autoPlayTimeout);
                    self._autoPlayTimeout = null;
                }
            }
        }
    });
    $.rsModules.autoplay = $.rsProto._initAutoplay;
})(jQuery);

jQuery(function($) {
    "use strict";
    // initialize CoEnvMenu plugin
    // IE9+ only
    $("html").not(".lt-ie9").coenvmenu();
});

(function($, window, document, undefined) {
    "use strict";
    // Plugin definition
    // =========================================================================
    $.CoEnvMenu = function(options, element) {
        this.options = options;
        this.element = $(element);
        this._create(options);
    };
    $.CoEnvMenu.settings = {
        outerSelector: "#outer",
        wrapperSelector: "#wrapper",
        menuSelector: ".main-menu",
        submenuClass: "children",
        topMenuSelector: ".top-menu",
        menuButtonSelector: "#show-menu button",
        topLevelItemSelector: ".page-depth-0",
        mobileMenuClass: "mobile-menu",
        normalMenuClass: "normal-menu",
        normalTopMenuClass: "normal-top-menu",
        mobileTopMenuClass: "mobile-top-menu",
        mobileMenuActiveClass: "mobile-menu-active",
        mobileTopMenuActiveClass: "mobile-top-menu-active",
        menuItemActiveClass: "menu-item-active"
    };
    // Create
    // =========================================================================
    $.CoEnvMenu.prototype._create = function(options) {
        // set options
        this.options = $.extend(true, {}, $.CoEnvMenu.settings, options);
        // initialize
        this._init();
    };
    // Initialize
    // =========================================================================
    $.CoEnvMenu.prototype._init = function() {
        this.$outer = $(this.options.outerSelector);
        this.$wrapper = $(this.options.wrapperSelector);
        this.$menu = $(this.options.menuSelector);
        this.$topMenu = $(this.options.topMenuSelector);
        this.$menuButton = $(this.options.menuButtonSelector);
        // set up menu DOM structure
        this._buildMenu();
        // handle main menu dropdowns
        this._dropdowns();
        // set up mobile menu
        this._setupMobileMenu();
        // add arrow icons before nav items
        this._addArrowIcons();
        // set up top menu
        this._setupTopMenu();
        // handle menu button interactions
        this._handleMenuButton();
        // handle clicking on this.$wrapper when mobile menu is active
        this._handleWrapperClicking();
        // handle interacting on top level items in mobile menu
        this._handleMenuInteractions();
        // handle window resize with mobile menu still visible
        this._handleWindowResize();
    };
    /**
	 * Build menu DOM structure
	 */
    $.CoEnvMenu.prototype._buildMenu = function() {
        var _this = this;
        // select top level menu items
        var $navItem = this.$menu.find(this.options.topLevelItemSelector);
        // select all submenus in the menu
        var $submenu = $navItem.find("> ." + this.options.submenuClass);
        var $submenuContainer = $('<div class="submenu-container"></div>');
        // divide each submenu's items into two columns
        $submenu.each(function() {
            var $items = $(this).find("> li"), itemsLength = $items.length, colBreak = Math.round(itemsLength / 2);
            // wrap items in left and right columns
            $items.slice(0, colBreak).wrapAll('<li class="col-left"><ul></ul></li>');
            $items.slice(colBreak, itemsLength).wrapAll('<li class="col-right"><ul></ul></li>');
        });
        // for each top level nav item
        $navItem.each(function() {
            var $link = $(this).find("> span > a"), linkTitle = $link.attr("title"), title, url;
            title = linkTitle !== undefined && linkTitle !== false ? linkTitle : $link.text();
            url = $link.attr("href");
            // add submenu if it does not exist
            if (!$(this).find("> ." + _this.options.submenuClass).length) {
                $(this).append('<ul class="' + _this.options.submenuClass + '"></ul>');
            }
            $(this).find("> ." + _this.options.submenuClass).prepend('<li class="pagenav"><a href="' + url + '">' + title + "</a></li>");
        });
        // wrap first sub menu in .submenu-container
        this.$menu.find(this.options.topLevelItemSelector + " > ." + this.options.submenuClass).wrap($submenuContainer);
    };
    // Handle dropdowns
    // =========================================================================
    $.CoEnvMenu.prototype._dropdowns = function() {
        var _this = this;
        // use hover intent to apply active class to top level nav items
        this.$menu.find(this.options.topLevelItemSelector).has("." + this.options.submenuClass).hoverIntent(function() {
            $(this).toggleClass(_this.options.menuItemActiveClass);
        });
    };
    // Set up mobile menu
    // =========================================================================
    $.CoEnvMenu.prototype._setupMobileMenu = function() {
        // make a copy of this.$menu to place behind this.$wrapper within this.$outer
        this.$mobileMenu = this.$menu.clone();
        this.$mobileMenu.removeClass(this.options.normalMenuClass).addClass(this.options.mobileMenuClass);
        // add a "home" link to the top of the mobile menu
        //this.$mobileMenu.find('ul').prepend('<li><a href="/">Home</a></li>');
        this.$mobileMenu.appendTo(this.$outer).show();
    };
    // Add arrow icons to menu items
    // =========================================================================
    $.CoEnvMenu.prototype._addArrowIcons = function() {
        this.$mobileMenu.find(this.options.topLevelItemSelector).has("." + this.options.submenuClass).each(function() {
            $(this).find("a").first().prepend("<i></i>");
        });
    };
    // Set up top links menu
    // =========================================================================
    $.CoEnvMenu.prototype._setupTopMenu = function() {
        // make a copy of this.$topMenu to place within this.$mobileMenu
        this.$mobileTopMenu = this.$topMenu.clone();
        this.$mobileTopMenu.removeClass(this.options.normalTopMenuClass).addClass(this.options.mobileTopMenuClass);
        this.$mobileTopMenu.appendTo(this.$mobileMenu).show();
    };
    // Handle menu button interactions
    // =========================================================================
    $.CoEnvMenu.prototype._handleMenuButton = function() {
        var _this = this;
        // handle clicking on menu button (using fastClick)
        this.$menuButton.fastClick(function(e) {
            e.preventDefault();
            _this._toggleMobileMenu();
        });
    };
    // Show/hide mobile menu
    // =========================================================================
    $.CoEnvMenu.prototype._toggleMobileMenu = function() {
        $("html").toggleClass(this.options.mobileMenuActiveClass);
    };
    // Handle window resize when mobile menu is still visible
    // =========================================================================
    $.CoEnvMenu.prototype._handleWindowResize = function() {
        var _this = this;
        $(window).on("resize", $.debounce(100, function() {
            if ($(window).width() >= 768 && $("html").hasClass(_this.options.mobileMenuActiveClass)) {
                _this._toggleMobileMenu();
            }
        }));
    };
    // Handle clicking on this.$wrapper when mobile menu is active
    // =========================================================================
    $.CoEnvMenu.prototype._handleWrapperClicking = function() {
        var _this = this;
        this.$wrapper.on("click", function(e) {
            if ($("html").hasClass(_this.options.mobileMenuActiveClass)) {
                e.preventDefault();
                _this._toggleMobileMenu();
            }
        });
    };
    // Handle menu interactions
    // =========================================================================
    $.CoEnvMenu.prototype._handleMenuInteractions = function() {
        var _this = this, $items = this.$mobileMenu.find(this.options.topLevelItemSelector), $itemLinks = $items.find("> span > a");
        // on page load, make sure appropriate item has the expanded class
        $items.filter(".menu-item-active, .current_page_item, .current-page-ancestor").each(function() {
            $(this).addClass("expanded");
        });
        $itemLinks.fastClick(function(e) {
            e.preventDefault();
            var $item = $(this).parents(_this.options.topLevelItemSelector), $icon = $(this).find("i"), $subMenu = $item.find("." + _this.options.submenuClass);
            if ($item.hasClass("expanded")) {
                $subMenu.slideUp(200);
                $item.removeClass("expanded");
            } else {
                $subMenu.slideDown(200);
                $item.addClass("expanded");
            }
        });
    };
    // Plugin bridge
    // =========================================================================
    // Leverages data method to either create or return plugin constructor
    //
    // Pattern developed by desandro for Masonry
    //		https://github.com/desandro/masonry/blob/master/jquery.masonry.js
    // Based off of jQuery UI's widget factory
    //		https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js
    // And a bit from jcarousel
    //		https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js
    $.CoEnvMenu.prototype.option = function(key) {
        if ($.isPlainObject(key)) {
            this.options = $.extend(true, this.options, key);
        }
    };
    $.fn.coenvmenu = function(options) {
        if (typeof options === "string") {
            // call method
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
                var instance = $.data(this, "coenvmenu");
                if (!instance) {
                    console.log("error", "cannot call methods on coenvmenu prior to initialization; " + 'attempted to call method "' + options + '"');
                    return;
                }
                if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                    console.log("error", 'no such method "' + options + '" for coenvmenu instance');
                    return;
                }
                // apply method
                instance[options].apply(instance, args);
            });
        } else {
            this.each(function() {
                var instance = $.data(this, "coenvmenu");
                if (instance) {
                    // apply options & init
                    instance.option(options || {});
                    instance._init();
                } else {
                    // initialize new instance
                    $.data(this, "coenvmenu", new $.CoEnvMenu(options, this));
                }
            });
        }
        return this;
    };
})(jQuery, window, document);

jQuery(function($) {
    "use strict";
    // no feature animations for < ie8
    if (!$("body").hasClass("lt-ie8")) {
        $(".home #features").homeFeatures();
    }
});

$.fn.homeFeatures = function() {
    "use strict";
    var $container = $(this), $rsContainer = $container.find(".features-container"), $features = $container.find(".feature"), $nav = $("<div></div>"), offsetTop, rsInstance, navOutput;
    if (!$rsContainer.length) {
        return;
    }
    offsetTop = $rsContainer.offset().top;
    // init royalSlider
    $rsContainer.royalSlider({
        loop: true,
        fadeInLoadedSlide: false,
        autoHeight: true,
        navigateByClick: false,
        autoPlay: {
            enabled: true,
            pauseOnHover: true,
            stopAtAction: false,
            delay: 8e3
        }
    });
    rsInstance = $rsContainer.data("royalSlider");
    $features.removeClass("loading");
    // start/stop autoplay when scrolling up or down past 
    // halfway point of feature
    $(window).on("scroll", $.debounce(200, function() {
        var scrollTop = $(window).scrollTop(), rsContainerOffset = $rsContainer.offset().top, rsContainerHeight = $rsContainer.outerHeight(true);
        if (scrollTop > rsContainerOffset + rsContainerHeight / 2) {
            rsInstance.stopAutoPlay();
        } else {
            rsInstance.startAutoPlay();
        }
    }));
    // set up nav links
    navOutput = "<ul>";
    $nav.addClass("features-nav");
    for (var i = 0, len = rsInstance.numSlides; i < len; i++) {
        navOutput += '<li><a href="#"><span>' + (i + 1) + "</span></a></li>";
    }
    navOutput += "</ul>";
    $nav.append($(navOutput));
    $nav.appendTo($container);
    $nav.find("a").eq(rsInstance.currSlideId).addClass("active");
    $nav.find("a").on("click", function(e) {
        e.preventDefault();
        $rsContainer.royalSlider("goTo", $(this).parent().index());
        $nav.find("a").removeClass("active");
        $(this).addClass("active");
    });
    // update nav on slide change
    rsInstance.ev.on("rsAfterSlideChange", function() {
        $nav.find("a").removeClass("active");
        $nav.find("a").eq(rsInstance.currSlideId).addClass("active");
    });
};

jQuery(function($) {
    "use strict";
    // handle blog header form
    $("#blog-header").blogHeader();
});

$.fn.blogHeader = function() {
    "use strict";
    var $header = $(this), $selectCategory = $header.find(".select-category select"), $selectMonth = $header.find(".select-month select");
    $selectCategory.on("change", function() {
        var term_id = $(this).val(), url = $(this).parent("div").attr("data-url");
        window.location.href = url + term_id;
    });
    $selectMonth.on("change", function() {
        var url = $(this).val();
        window.location.href = url;
    });
};

/**
 * Share modals
 * for blog posts
 */
(function($, window, document, undefined) {
    "use strict";
    // Plugin definition
    // =========================================================================
    $.coenvshare = function(options, element) {
        this.options = options;
        this.element = $(element);
        this._create(options);
    };
    $.coenvshare.settings = {};
    // Create
    // =========================================================================
    $.coenvshare.prototype._create = function(options) {
        // set options
        this.options = $.extend(true, {}, $.coenvshare.settings, options);
        // initialize
        this._init();
    };
    // Initialize
    // =========================================================================
    $.coenvshare.prototype._init = function() {
        this.articleID = this.element.attr("data-article-id");
        this.articleTitle = this.element.attr("data-article-title");
        this.articleShortLink = this.element.attr("data-article-shortlink");
        this.articlePermalink = this.element.attr("data-article-permalink");
        // show share button
        // must have data-article-id set
        if (typeof this.articleID !== "undefined" && typeof this.articleTitle !== "undefined" && typeof this.articleShortLink !== "undefined" && typeof this.articlePermalink !== "undefined") {
            this.element.addClass("active");
        } else {
            return;
        }
        // build modal
        this._buildModal();
        // handle interactions
        this._interactions();
    };
    /**
	 * Build modal
	 * Building DOM elements here to keep things quick and simple, but this should really be in a template
	 */
    $.coenvshare.prototype._buildModal = function() {
        var services = [ {
            name: "Twitter",
            className: "twitter",
            url: "http://twitter.com/home?status=" + this.articleTitle + " " + this.articleShortLink + ' from @UW_CoEnv" target="_blank'
        }, {
            name: "Facebook",
            className: "facebook",
            url: "http://www.facebook.com/sharer/sharer.php?s=100&p[url]=" + this.articleShortLink + "&p[images][0]=&p[title]=" + this.articleTitle + ' from UW College of the Environment" target="_blank'
        }, {
            name: "Email",
            className: "email",
            url: "mailto:?subject=" + this.articleTitle + "&body=Check%20out%20this%20article%20from%20the%20UW%20College%20of%20the%20Environment:%20" + this.articleShortLink
        } ];
        this.$modal = $('<div class="share-modal" role="dialog" aria-labelledby="shareModal" aria-hidden="true"></div>');
        this.$modal.append('<div class="share-modal-inner"><ul class="share-modal-content"></ul></div>');
        for (var i = 0, len = services.length; i < len; i++) {
            this.$modal.find(".share-modal-content").append('<a href="' + services[i].url + '" ><li class="social-link share-' + services[i].className + '"></li></a>');
        }
    };
    /**
	 * Handle interactions
	 */
    $.coenvshare.prototype._interactions = function() {
        var _this = this;
        // clicking on link
        this.element.on("click", function(ev) {
            ev.preventDefault();
            ev.stopPropagation();
            _this._launchModal();
        });
        // clicking outside of modal
        $("body").on("click", function(ev) {
            if (_this.modalIsActive === true) {
                if (!$(ev.target).is(".social-link")) {
                    _this._hideModal();
                }
            }
        });
    };
    /**
	 * Launch share modal
	 */
    $.coenvshare.prototype._launchModal = function() {
        var _this = this;
        // append modal
        $(".post-" + this.articleID).prepend(this.$modal);
        // show modal
        this.$modal.addClass("active");
        this.modalIsActive = true;
        setTimeout(function() {
            _this.$modal.addClass("active-visible");
        }, 10);
    };
    /**
	 * Hide modal
	 */
    $.coenvshare.prototype._hideModal = function() {
        var _this = this;
        this.$modal.removeClass("active-visible");
        //setTimeout( function () {
        _this.$modal.removeClass("active");
        _this.$modal.remove();
        _this.modalIsActive = false;
    };
    // Plugin bridge
    // =========================================================================
    // Leverages data method to either create or return plugin constructor
    //
    // Pattern developed by desandro for Masonry
    //		https://github.com/desandro/masonry/blob/master/jquery.masonry.js
    // Based off of jQuery UI's widget factory
    //		https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js
    // And a bit from jcarousel
    //		https://github.com/jsor/jcarousel/blob/master/lib/jquery.jcarousel.js
    $.coenvshare.prototype.option = function(key) {
        if ($.isPlainObject(key)) {
            this.options = $.extend(true, this.options, key);
        }
    };
    $.fn.coenvshare = function(options) {
        if (typeof options === "string") {
            // call method
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function() {
                var instance = $.data(this, "coenvshare");
                if (!instance) {
                    console.log("error", "cannot call methods on coenvshare prior to initialization; " + 'attempted to call method "' + options + '"');
                    return;
                }
                if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                    console.log("error", 'no such method "' + options + '" for coenvshare instance');
                    return;
                }
                // apply method
                instance[options].apply(instance, args);
            });
        } else {
            this.each(function() {
                var instance = $.data(this, "coenvshare");
                if (instance) {
                    // apply options & init
                    instance.option(options || {});
                    instance._init();
                } else {
                    // initialize new instance
                    $.data(this, "coenvshare", new $.coenvshare(options, this));
                }
            });
        }
        return this;
    };
})(jQuery, window, document);

jQuery(function($) {
    "use strict";
    if (!$("body").hasClass("lt-ie8")) {
        // use chosen for form inputs
        $("select.chosen").chosen();
        // placeholders for older browsers
        $("input, textarea").placeholder();
        // fitvids for responsive videos
        $(".article-content").handleFitVids();
        // single faculty member tabs
        $(".Faculty-member-tab-nav").memberTabs();
        // banner image reveals
        $(".banner-wrapper").bannerReveals();
        // share buttons
        $(".share").coenvshare();
        // lightbox
        $("a").nivoLightbox();
    }
});

/**
 * Banner image reveals
 */
$.fn.bannerReveals = function() {
    "use strict";
    return this.each(function() {
        var $container = $(this), $revealBtn = $(".banner-info"), activeClass = "banner-revealed";
        $revealBtn.on("click", function(e) {
            e.preventDefault();
            e.stopPropagation();
            $("body").toggleClass(activeClass);
        });
        $container.on("click", function() {
            if ($("body").hasClass(activeClass)) {
                $("body").removeClass(activeClass);
            }
        });
    });
};

/**
 * Handle responsive videos
 */
$.fn.handleFitVids = function() {
    "use strict";
    $(this).fitVids();
    $(".fluid-width-video-wrapper").each(function() {
        var $this = $(this), maxWidth = parseFloat($this.css("max-width")), paddingTop = parseFloat($this[0].style["padding-top"]);
        // increase padding-top relative to max-width set on this element
        var adjustment = maxWidth * (paddingTop * .01) + "%";
        $this.css("padding-top", adjustment);
    });
};

$.fn.memberTabs = function() {
    "use strict";
    var $nav = $(this), $tabs = $(".Faculty-member-tabs"), activeClass = "active-tab";
    $nav.find("a").click(function(e) {
        e.preventDefault();
        var $navItem = $(this), $tab = $tabs.find("." + $(this).attr("data-tab"));
        $nav.find("." + activeClass).removeClass(activeClass);
        $(this).parent("li").addClass(activeClass);
        $tabs.find("." + activeClass).removeClass(activeClass);
        $tab.addClass(activeClass);
    });
};
//# sourceMappingURL=main.min.map